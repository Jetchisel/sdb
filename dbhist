# ============================================================================================ #
#: Title           : dbhist                                                                    #
#: Sypnosis        : dbhist [OPTIONS]... [QUERY]...                                            #
#: Date Created    : Sat 25 Nov 2017 10:10:47 AM +08  /  Sat Nov 25 02:10:47 UTC 2017          #
#: Last Edit       : Tue 19 Dec 2017 08:18:33 AM +08  /  Tue Dec 19 00:18:33 UTC 2017          #
#: License         : MIT                                                                       #
#: Version         : 1.4.0                                                                     #
#: Maintainer      : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : log bash_history in a database (A fork of dbhist.sh from Dennis Gladkikh) #
#: Options         : [abcehmnpsuvwzHS]                                                         #
#: Home Page       :                                                                           #
#: ExtComm         : sqlite3                                                                   #
# ============================================================================================ #

################################################################################################
# The MIT License                                                                              #
# SPDX short identifier: MIT                                                                   #
#                                                                                              #
# Further resources on the MIT License                                                         #
# Copyright 2017 Denis Gladkikh (https://www.outcoldman.com/en/archive/2017/07/19/dbhist/)     #
#                                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy                 #
# of this software and associated documentation files (the "Software"), to deal                #
# in the Software without restriction, including without limitation the rights                 #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                    #
# copies of the Software, and to permit persons to whom the Software is                        #
# furnished to do so, subject to the following conditions:                                     #
#                                                                                              #
# The above copyright notice and this permission notice shall be included in                   #
# all copies or substantial portions of the Software.                                          #
#                                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                #
# SOFTWARE.                                                                                    #
#                                                                                              #
#==============================================================================================#
#                                                                                              #
# To use it, just source the file `source dbhist`                                              #
#                                                                                              #
# Configuration                                                                                #
#   DBHISTORY=true - use false to disable                                                      #
#   DBHISTORYFILE=$HOME/.bash_history.sqlite  - location of dbhist sqlite3 database.           #
#                                                                                              #
# To make it work I keep next configuration for bash, the only important is the                #
# time format, to make it unixtime                                                             #
#                                                                                              #
#   HISTSIZE=$HOME/.bash_history                                                               #
#   HISTFILESIZE=1000                                                                          #
#   HISTSIZE=1000                                                                              #
#   HISTTIMEFORMAT="%s "                                                                       #
#   HISTCONTROL=ignorespace:erasedups                                                          #
#                                                                                              #
#                                                                                              #
################################################################################################

# ******************************************************************************************** #
#                                                                                              #
#                       Enable extglob, just in case it is not enabled.                        #
#                                                                                              #
# ******************************************************************************************** #

shopt -s extglob

# ******************************************************************************************** #
#                                                                                              #
#                               Function to show the help menu.                                #
#                                                                                              #
# ******************************************************************************************** #

____ShowHelp____() {

  local IFS help

IFS=$'\n' read -rd '' help <<<"
USAGE: ${BASH_SOURCE##*/} [OPTIONS]... [QUERY]...

Records bash_history to a database and query it.
Without any options/arguments the default is to show
the recent commands if there is/are any in the current
session.

OPTIONS:
  -a, --all               Include history of all sessions. Not only current.
  -b, --begin word        Match only commands that starts with word.
  -e, --status            Show the exit status of the commands.
  -h, --help              Show this help.
  -c, --cwd               Show the working directory of the commands.
  -w, --whole-line word   Match commands with word from beginning to end.
  -m, --max n             N numbers of latest commands to show. Defaults to 100.
  -n, --non-zero          Show commands that exited with non-zero status.
  -p, --path dir          Show commands executed inside the directory dir.
  -s, --self              Include history about ${BASH_SOURCE##*/}.
  -u, --under             Reduce search only for current and under pwd.
  -v, --verbose           Verbose output (shows sql command).
  -z, --zero              Show commands that exited with zero status.
  -H, --here              Reduce search only for current pwd.
  -S, --shell             Access to the sqlite3 shell.

Long options that takes an argument also supports the following syntax:

    --option=argument

Short options that does not take an argument ca be joined as one command:

    -aecnsuv

A newly open shell does not have any commands to show
unless the -a option is specified, which defaults to
100 lines, unless the -l option is specified.

The 1rst column shows only the increment of the executed commands.
The 2nd column shows the date and time of the executed commands.
The 3rd column shows how many times the commands has been executed.
The 4rth & 5fth column which is specified by the -e option shows the exit status.
The 6th column which is specified by the -c option shows the pwd.
The last column is the executed commands.

 1rst | 2nd | 3rd | 4rth: 5fth | 6th > last

NOTE:
  Not all commands that exited with a non-zero is a failure, likewise not all commands
  that exited with zero is a success.
"
  printf '%s\n' "$help"
}

# ******************************************************************************************** #
#                                                                                              #
#                                      The magic starts.                                       #
#                                                                                              #
# ******************************************************************************************** #

if ${DBHISTORY:-true}; then

  __dbhist_salt="$RANDOM$RANDOM"

  __dbhist_initialized=0

  __dbhist_oldpwd="$OLDPWD"

  __dbhist_empty_data_base=0
  __dbhist_does_not_exists=0

  __dbhist_file="${DBHISTORYFILE:-$HOME/.bash_history.sqlite}"

  __dbhist_sqlite() {
    sqlite3 "$__dbhist_file"
  }

  __db_hist_init() {
    local __sql='CREATE TABLE history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hist_id INTEGER,
    cmd TEXT,
    epoch INTEGER,
    ppid INTEGER,
    status TEXT,
    exit_status INTEGER,
    pwd TEXT,
    salt INTEGER
    );'

    if [[ ! -f "$__dbhist_file" ]]; then
       __dbhist_sqlite <<< "$__sql"
    fi
  }

  __db_hist_prompt() {

    if [[ -f ~/dotfiles/prompt ]]; then
      source ~/dotfiles/prompt
    else
      Last_Command=$?
    fi

    if ((!__dbhist_initialized)); then
      __db_hist_init
      __dbhist_initialized=1
      return
    fi

    if ((!__dbhist_does_not_exists)); then
      if [[ ! -f $__dbhist_file ]]; then
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "It looks like $__dbhist_file does not exists, please verify it." >&2
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "run: file $__dbhist_file" >&2
        __dbhist_does_not_exists=1
        return
      fi
    fi

    if ((!__dbhist_empty_data_base)); then
      if [[ ! -s $__dbhist_file  ]]; then
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "It looks like $__dbhist_file is empty, please verify it." >&2
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "run: file $__dbhist_file" >&2
        __dbhist_empty_data_base=1
        return
      fi
    fi

    if [[ -n ${COMP_LINE} ]]; then
      return
    fi

    local IFS
    local line
    local formated_history=""
    local num=""
    local epoch=""
    local pwd=$PWD
    local command=""
    local first=""
    local secondtemp0=""
    local secondtemp1=""
    local second=""
    local thirdtemp0=""
    local third=""

    if [[ $OLDPWD !=  $__dbhist_oldpwd ]]; then
      pwd=$OLDPWD
      __dbhist_oldpwd=$OLDPWD
    fi

# ******************************************************************************************** #
#                                                                                              #
# Set IFS to a newline, use reads -d option, so multiline command such a heredocs is captured. #
#                                                                                              #
# ******************************************************************************************** #

    IFS=$'\n' read -u 5 -rd ''  formated_history 5< <(history 1)

# ******************************************************************************************** #
#                                                                                              #
#   Parameter expansion to extract the data/info from "history 1" and split it into 3 parts.   #
#                                                                                              #
# ******************************************************************************************** #

    read -u 6 -r line 6<<< "$formated_history"
    first="${line%%[[:space:]]*}"
    secondtemp0="${line##*"${first}"}"
    secondtemp1=${secondtemp0##*( )}
    second="${secondtemp1%%[[:space:]]*}"

    IFS=$'\n' read -u 7 -rd '' line  7<<< "$formated_history"
    thirdtemp0="${line##*"${second}"}"
    third="${thirdtemp0##*( )}"

    num=$first
    epoch=$second
    command=$third

# ******************************************************************************************** #
#                                                                                              #
#           Insert data from the variables to the sqlite3 database using a heredoc.            #
#                                                                                              #
# ******************************************************************************************** #

    __dbhist_sqlite <<-END
INSERT INTO history(hist_id, epoch, cmd, ppid, status, exit_status, pwd, salt)
VALUES(
  "${num}",
  "${epoch}",
  "${command//\"/\"\"}",
  "${PPID}",
  "Status",
  "${Last_Command}",
  "${pwd//\"/\"\"}",
  "${__dbhist_salt}"
);
END

}

  dbhist() {

# ******************************************************************************************** #
#                                                                                              #
#                         Local variables from dbhist prompt function.                         #
#                                                                                              #
# ******************************************************************************************** #

     local max=100
     local all=0
     local exit_stat=0
     local self=0
     local whole_line=0
     local path=0
     local verbose=0
     local pwd=0
     local zero=0
     local nonzero=0
     local ExitStatus=""
     local pathquery=""
     local query=""
     local location=""
     local optstring

# ******************************************************************************************** #
#                                                                                              #
#                      Getops from scratch, by: D.J. Mills aka e36freak.                       #
#                                                                                              #
# ******************************************************************************************** #

     declare -a options

     optstring=acesunvzHSb:m:w:p:

     unset options
     while (($#)); do
       case $1 in

         -[!-]?*)

           for ((i=1; i<${#1}; i++)); do
             c=${1:i:1}

             options+=("-$c")


             if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
               options+=("${1:i+1}")
               break
             fi
           done
           ;;

         --?*=*) options+=("${1%%=*}" "${1#*=}");;

         --) options+=(--endopts);;

         *) options+=("$1");;
       esac
       shift
     done

     set -- "${options[@]}"

     if (( ${#options[@]} == 1 )); then
       if [[ ${options[0]} != -* ]]; then
         printf '%s\n' "Unknown option ${options[0]}" 'Try --help'
         return 1
       fi
     fi

     unset options

# ******************************************************************************************** #
#                                                                                              #
#                          Parse the command line arguments/options.                           #
#                                                                                              #
# ******************************************************************************************** #

     while [[ $1 = -?* ]]; do
       case $1 in
         --shell|-S)
           __dbhist_sqlite
           return
           ;;
         --help|-h)
           ____ShowHelp____
           return
           ;;
         --max|-m)
           shift
           max=${1:?option require value}
           if [[ $max != +([0-9]) ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Maxlimit should be a number!' >&2
             return 1
           fi
           ;;
         --all|-a)
           all=1
           ;;
         --status|-e)
           exit_stat=1
           ;;
         --self|-s)
           self=1
           ;;
         --begin-with|-b)
           shift
           begin=1
           if ((whole_line)); then
             printf '%s\n' 'Conflicting options!'
             return 1
           fi
           query=${1:?requires value}
           ;;
         --path|-p)
           shift
           path=1
           pwd=1
           pathquery=${1:?requires value}
           ;;
         --verbose|-v)
           verbose=1
           ;;
         --whole-line|-w)
           shift
           whole_line=1
           if ((begin)); then
             printf '%s\n' 'Conflicting options!'
             return 1
           fi
           query=${1:?requires value}
           ;;
         --here|-H)
           if [[ -n $location || -n $pathquery ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Specifier for pwd already set!' >&2
             return 1
           fi
           location=here
           ;;
         --under|-u)
           if [[ -n $location || -n $pathquery ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Specifier for pwd already set!' >&2
             return 1
           fi
           location=under
           ;;
         --cwd|-c)
           pwd=1
           ;;
         --non-zero|-n)
           nonzero=1
           exit_stat=1
           ;;
         --zero|-z)
           zero=1
           exit_stat=1
           ;;
         --endopts)
           shift
           break;;
         *)
           printf '%s: %s: %s\n' "${BASH_SOURCE##*/}" "Unknown option" "$1" >&2
           return 1
           ;;
       esac
       shift
     done

     if ((exit_stat)); then
       ExitStatus="substr('      '||max(status),-6) ||
       ': ' ||
       substr('      '||max(exit_status),-4) ||
       ' | ' ||"
     fi

     pwd_q=""
     if ((pwd)); then
       pwd_q='pwd || " > " ||'
     fi

     local sql_commands="
       SELECT
       substr('      '||max(id),-6) ||
         ' | ' ||
         datetime(max(epoch), 'unixepoch', 'localtime') ||
         ' | ' ||
         substr('      '||count(*),-6) ||
         ' | ' ||
         $ExitStatus
         $pwd_q
       cmd
       FROM history
       WHERE 1 "

     if ((!all)); then
       sql_commands+="AND (salt=$__dbhist_salt AND ppid=$PPID) "
     fi

     if ((!self)); then
       sql_commands+="AND (cmd != 'dbhist' AND cmd NOT LIKE 'dbhist %') "
     fi

     if [[ -n $query ]]; then
       query=${query//\"/\"\"}
       if ((begin)); then
         query+="%"
       elif ((whole_line)); then
         query="%$query%"
       fi
       sql_commands+="AND cmd LIKE \"$query\" ESCAPE '\' "
     fi

     pwd_l=${PWD//\"/\"\"}

     case $location in
       here)
         sql_commands+="AND (pwd == \"$pwd_l\") "
         ;;
       under)
         pwd_l=${pwd_l//%/\%}
         pwd_l=${pwd_l//_/\_}
         sql_commands+="AND (pwd LIKE \"$pwd_l%\" ESCAPE '\') "
         ;;
     esac

     if ((path)); then
       sql_commands+="AND pwd = \"${pathquery//\\//\/}\" "
     fi

     if ((zero)); then
       if ((nonzero)); then
         printf '%s\n' 'Conflicting options!'
         return 1
       fi
        sql_commands+="AND exit_status = '0' "
     fi

     if ((nonzero)); then
       if ((zero)); then
         printf '%s\n' 'Conflicting options!'
         return 1
       fi
        sql_commands+="AND exit_status > '0' "
     fi

     sql_commands+="GROUP BY cmd, exit_status "

     if ((pwd)); then
       sql_commands+=", pwd "
     fi

     sql_commands+="ORDER BY max(id) DESC LIMIT $max ;"

     if ((verbose)); then
       printf '%s\n' "database: $__dbhist_file" 'sql:' "$sql_commands" "${blank_line:-""}"
     fi

     __dbhist_sqlite <<< "$sql_commands"
  }

fi

# ******************************************************************************************** #
#                                                                                              #
#          assign the function __db_hist_prompt to the bash variable PROMPT_COMMAND.           #
#                                                                                              #
# ******************************************************************************************** #

if [[ $PROMPT_COMMAND != *__db_hist_prompt* ]]; then
  PROMPT_COMMAND="__db_hist_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
fi

# ============================================================================================ #
#                                                                                              #
#                                   >>> END OF SCRIPT <<<                                      #
#                                                                                              #
# ============================================================================================ #
