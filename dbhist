# ============================================================================================ #
#: Title           : dbhist                                                                    #
#: Sypnosis        : dbhist [OPTIONS]... [QUERY]...                                            #
#: Date Created    : Sat 25 Nov 2017 10:10:47 AM +08  /  Sat Nov 25 02:10:47 UTC 2017          #
#: Last Edit       : Fri 08 Dec 2017 13:40:15 PM +08  /  Fri Dec  8 05:40:15 UTC 2017          #
#: License         : MIT                                                                       #
#: Version         : 1.0.0                                                                     #
#: Maintainer      : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : log bash_history in a database (A fork of dbhist.sh from Dennis Gladkikh) #
#: Options         : --[pwd|here|all|self|starts|verbose|under|shell|limit]                    #
#: Home Page       :                                                                           #
#: ExtComm         : sqlite3                                                                   #
# ============================================================================================ #

################################################################################################
# The MIT License                                                                              #
# SPDX short identifier: MIT                                                                   #
#                                                                                              #
# Further resources on the MIT License                                                         #
# Copyright 2017 Denis Gladkikh (https://www.outcoldman.com/en/archive/2017/07/19/dbhist/)     #
#                                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy                 #
# of this software and associated documentation files (the "Software"), to deal                #
# in the Software without restriction, including without limitation the rights                 #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                    #
# copies of the Software, and to permit persons to whom the Software is                        #
# furnished to do so, subject to the following conditions:                                     #
#                                                                                              #
# The above copyright notice and this permission notice shall be included in                   #
# all copies or substantial portions of the Software.                                          #
#                                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                #
# SOFTWARE.                                                                                    #
#                                                                                              #
#==============================================================================================#
#                                                                                              #
# To use it, just source the file `source dbhist.sh`                                           #
#                                                                                              #
# Configuration                                                                                #
#   DBHISTORY=true - use false to disable                                                      #
#   DBHISTORYFILE=$HOME/.dbhist - location of dbhist file                                      #
#                                                                                              #
# To make it work I keep next configuration for bash, the only important is the                #
# time format, to make it unixtime                                                             #
#                                                                                              #
#   HISTSIZE=$HOME/.bash_history                                                               #
#   HISTFILESIZE=1000                                                                          #
#   HISTSIZE=1000                                                                              #
#   HISTTIMEFORMAT="%s "                                                                       #
#   HISTCONTROL=ignorespace:erasedups                                                          #
#                                                                                              #
#                                                                                              #
################################################################################################

# ******************************************************************************************** #
#                                                                                              #
#                           Name of the script without the Pathname.                           #
#                                                                                              #
# ******************************************************************************************** #

____script_name____=${BASH_SOURCE##*/}

# ******************************************************************************************** #
#                                                                                              #
#                               Function to show the help menu.                                #
#                                                                                              #
# ******************************************************************************************** #

____ShowHelp____() {
       cat<<-END

USAGE: dbhist [OPTIONS]... [QUERY]...

Save bash_history to a database and show it to standard output.

OPTIONS:

--limit n     n numbers of latest commands to show. Defaults to 100.
--all         include history of all sessions. Not only current.
--self        include history about dbhist
--starts      match only commands starts with query
--verbose     verbose output (shows sql)
--here        reduce search only for current pwd
--under       reduce search only for current and under pwd
--pwd         show working directory of cmd
--shell       access to shell

END

}

# ******************************************************************************************** #
#                                                                                              #
#                                      The magic starts.                                       #
#                                                                                              #
# ******************************************************************************************** #

if ${DBHISTORY:-true}; then

  # Kind of session ID, allows to see only commands executed in this terminal session
  __dbhist_salt="${RANDOM}${RANDOM}"
  # This allows us to verify existence of .dbhist file only once
  __dbhist_initialized=false
  # Keep the previous folder, this how we keep the PWD for commands like `cd ...`
  __dbhist_oldpwd="${OLDPWD}"

  __dbhist_empty_data_base=0
  __dbhist_does_not_exists=0

  # Get location of .dbhist file, default location is under `$HOME/.dbhist`
  __dbhist_file="${DBHISTORYFILE:-$HOME/.dbhist}"

  # Execute command on sqlite with .dbhist file
  __dbhist_sqlite() {
    sqlite3 "$__dbhist_file"
  }

  # Initialize dbhist file, create table
  __db_hist_init() {
    local __sql='CREATE TABLE history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hist_id INTEGER,
    cmd TEXT,
    epoch INTEGER,
    ppid INTEGER,
    pwd TEXT,
    salt INTEGER
    );'

    if [[ ! -f "$__dbhist_file" ]]; then
       __dbhist_sqlite <<< "${__sql}"
    fi
  }

  # Execute it with bash PROMPT
  __db_hist_prompt() {

    if ! ${__dbhist_initialized}; then
      __db_hist_init
      __dbhist_initialized=true
      return
    fi

    if ((!__dbhist_does_not_exists)); then
      if [[ ! -f $__dbhist_file ]]; then
        printf '%s: %s\n' "$____script_name____" "It looks like $__dbhist_file does not exists, please verify it." >&2
        printf '%s: %s\n' "$____script_name____" "run: file $__dbhist_file" >&2
        __dbhist_does_not_exists=1
        return
      fi
    fi

    if ((!__dbhist_empty_data_base)); then
      if [[ ! -s $__dbhist_file  ]]; then
        printf '%s: %s\n' "$____script_name____" "It looks like $__dbhist_file is empty, please verify it." >&2
        printf '%s: %s\n' "$____script_name____" "run: file $__dbhist_file" >&2
        __dbhist_empty_data_base=1
        return
      fi
    fi

    if [[ -n ${COMP_LINE} ]]; then
      return
    fi

    local IFS
    local regexp
    local __formated_history=""
    local __num=""
    local __epoch=""
    local __pwd=${PWD}

    if [[ ${OLDPWD} !=  ${__dbhist_oldpwd} ]]; then
      __pwd=${OLDPWD}
      __dbhist_oldpwd=${OLDPWD}
    fi

# ******************************************************************************************** #
#                                                                                              #
#          Save the recent bash command using "history 1" in a variable using "read"           #
#                                                                                              #
# ******************************************************************************************** #

    IFS=$'\n' read -rd '' __formated_history < <(history 1)

# ******************************************************************************************** #
#                                                                                              #
#        Using E.R.E and bash_rematch to split the output of "history 1" into 3 parts.         #
#                                                                                              #
# ******************************************************************************************** #

    regexp='[[:space:]]+([[:digit:]]+)[[:space:]]+([[:digit:]]+)[[:space:]](.+)'

    if [[ $__formated_history =~ $regexp ]]; then
      __num=${BASH_REMATCH[1]}
      __epoch=${BASH_REMATCH[2]}
      __command=${BASH_REMATCH[3]}
    fi

# ******************************************************************************************** #
#                                                                                              #
#                     Insert/feed the variables to sqlite3 using INSERT.                       #
#                                                                                              #
# ******************************************************************************************** #

    __dbhist_sqlite <<-END
INSERT INTO history(hist_id, epoch, cmd, ppid, pwd, salt)
VALUES("${__num}", "${__epoch}", "${__command//\"/\"\"}", "${PPID}", "${__pwd//\"/\"\"}", "${__dbhist_salt}");
END

}

  dbhist() {

# ******************************************************************************************** #
#                                                                                              #
#          Check for the required app/executable is with in your PATH, exit otherwise.         #
#                                                                                              #
# ******************************************************************************************** #

     ____Missing____=()
     ____ExtComm____=(sqlite3)
     ____Missing____Message="is either not installed or it is not in your PATH!"
     ____ExitMessage____="Please install the following: "

     for ____apps____ in "${____ExtComm____[@]}"; do
       if ! type -P "$____apps____" >/dev/null; then
         printf '%s %s\n' "$____apps____" "$____Missing____Message" >&2
         ____Missing____+=("$____apps____")
       fi
     done


     if (( ${#____Missing____[@]} )); then
       printf '%s\n' "$____ExitMessage____[${____Missing____[*]}] exiting now!" >&2
       return 127
     fi

# ******************************************************************************************** #
#                                                                                              #
#                         Local variables from dbhist prompt function.                         #
#                                                                                              #
# ******************************************************************************************** #

     local __limit=100
     local __all=false
     local __self=false
     local __starts=false
     local __verbose=false
     local __query=""
     local __location=""
     local __pwd=false

# ******************************************************************************************** #
#                                                                                              #
#                          Parse the command line arguments/options.                           #
#                                                                                              #
# ******************************************************************************************** #

     while (($#)); do
       case $1 in
         --shell)
           __dbhist_sqlite
           return
           ;;
         --help)
           ____ShowHelp____
           return
           ;;
         --limit)
           shift
           __limit=${1:?option require value}
           if [[ $__limit != +([0-9]) ]]; then
             printf '%s: %s\n' "$____script_name____" 'Limit should be a number!' >&2
             return 1
           fi
           ;;
         --all)
           __all=true
           ;;
         --self)
           __self=true
           ;;
         --starts)
           __starts=true
           ;;
         --verbose)
           __verbose=true
           ;;
         --here)
           if [[ -n ${__location} ]]; then
             printf '%s: %s\n' "$____script_name____" 'Specifier for pwd already set!' >&2
             return 1
           fi
           __location=here
           ;;
         --under)
           if [[ -n ${__location} ]]; then
             printf '%s: %s\n' "$____script_name____" 'Specifier for pwd already set!' >&2
             return 1
           fi
           __location=under
           ;;
         --pwd)
           __pwd=true
           ;;
         -*)
           printf '%s: %s: %s\n' "$____script_name____" "Unknown option" "$1" >&2
           return 1
           ;;
         *)
           if [[ -n ${__query} ]]; then
             printf  '%s: %s\n' "$____script_name____" "Cannot specify more than one query!" >&2
             return 1
           fi
           __query=${1:?requires value}
           ;;
       esac
       shift
     done

     __pwd_q=""
     if ${__pwd}; then
       __pwd_q='pwd || " > " ||'
     fi

     local __sql="
     SELECT
     substr('      '||max(id),-6) ||
       ' | ' ||
       datetime(max(epoch), 'unixepoch', 'localtime') ||
       ' | ' ||
       substr('      '||count(*),-6) ||
       ' | ' ||
       ${__pwd_q}
     cmd
     FROM history
     WHERE 1 "


     if ! ${__all}; then
       __sql+="AND (salt=${__dbhist_salt} AND ppid=${PPID}) "
     fi

     if ! ${__self}; then
       __sql+="AND (cmd != 'dbhist' AND cmd NOT LIKE 'dbhist %') "
     fi

     if [[ -n ${__query} ]]; then
       __query=${__query//\"/\"\"}
       if ! ${__starts} && [[ ${__query} != %* ]]; then
         __query="%${__query}"
       fi
       if [[ "${__query}" != *% ]]; then
         __query+="%"
       fi
       __sql+="AND cmd LIKE \"${__query}\" ESCAPE '\' "
     fi

     __pwd_l=${PWD//\"/\"\"}

     case ${__location} in
       here)
         __sql+="AND (pwd == \"${__pwd_l}\") "
         ;;
       under)
         __pwd_l=${__pwd_l//%/\%}
         __pwd_l=${__pwd_l//_/\_}
         __sql+="AND (pwd LIKE \"${__pwd_l}%\" ESCAPE '\') "
         ;;
     esac

     __sql+="GROUP BY cmd "

     if ${__pwd}; then
       __sql+=", pwd "
     fi

     __sql+="ORDER BY max(id) DESC LIMIT ${__limit} ;"

     if ${__verbose}; then
       printf '%s\n' "database: $__dbhist_file" 'sql:' "${__sql}" "${blank_line:-""}"
     fi

     __dbhist_sqlite <<< "${__sql}"
  }

fi

# ******************************************************************************************** #
#                                                                                              #
#          assign the function __db_hist_prompt to the bash variable PROMPT_COMMAND.           #
#                                                                                              #
# ******************************************************************************************** #

if [[ $PROMPT_COMMAND != *__db_hist_prompt* ]]; then
  PROMPT_COMMAND="__db_hist_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
fi

# ============================================================================================ #
#                                                                                              #
#                                   >>> END OF SCRIPT <<<                                      #
#                                                                                              #
# ============================================================================================ #
