# ============================================================================================ #
#: Title           : sdb                                                                       #
#: Sypnosis        : sdb [OPTIONS]... [QUERY]...                                               #
#: Date Created    : Sat 25 Nov 2017 10:10:47 AM +08  /  Sat Nov 25 02:10:47 UTC 2017          #
#: Last Edit       : Sat 08 Sep 2018 10:47:50 AM +08  /  Sat Sep  8 02:47:50 UTC 2018          #
#: License         : MIT                                                                       #
#: Version         : 3.4.8                                                                     #
#: Maintainer      : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : Log bash_history in a database (A fork of dbhist.sh by Dennis Gladkikh)   #
#: Options         : [abcdehlmnoprsuvwAEMST?]                                                  #
#: Home Page       : https://github.com/Jetchisel/sdb                                          #
#: ExtComm         : base64,date,dd,less,mktemp,whoami,realpath,rm,sqlite3,tput,uname          #
#: Copyright       : Jason V. Ferrer 2017-2018                                                 #
# ============================================================================================ #

################################################################################################
# The MIT License                                                                              #
# SPDX short identifier: MIT                                                                   #
#                                                                                              #
# Further resources on the MIT License                                                         #
# Copyright 2017 Denis Gladkikh (https://www.outcoldman.com/en/archive/2017/07/19/dbhist/)     #
# Copyright 2017-2018 Jason V. Ferrer based on above.                                          #
#                                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy                 #
# of this software and associated documentation files (the "Software"), to deal                #
# in the Software without restriction, including without limitation the rights                 #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                    #
# copies of the Software, and to permit persons to whom the Software is                        #
# furnished to do so, subject to the following conditions:                                     #
#                                                                                              #
# The above copyright notice and this permission notice shall be included in                   #
# all copies or substantial portions of the Software.                                          #
#                                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                #
# SOFTWARE.                                                                                    #
#                                                                                              #
#==============================================================================================#
# Configuration:                                                                               #
#   Add the following entry in your shell rc file, e.g. "$HOME/.bashrc"                        #
#                                                                                              #
#   if [[ "$(set -o | awk '$1 == "history" {print $2}')" = off ]]; then                        #
#     set -o history                                                                           #
#   fi                                                                                         #
#   HISTSIZE=1000                                                                              #
#   HISTTIMEFORMAT="%s "                                                                       #
#   HISTFILE=$HOME/.bash_history                                                               #
#   HISTCONTROL=ignorespace:erasedups                                                          #
#   SDB_HISTORY=true                                                                           #
#   SDB_DATABASE=$HOME/.bash_history.sqlite                                                    #
#                                                                                              #
#   Change The value of SDB_HISTORY from "true" to "false" to disable sdb.                     #
#   Change the value of SDB_DATABASE to something/somewhere else for multi-user set up.        #
#                                                                                              #
# Using the script:                                                                            #
#   if the script is in the current pwd.                                                       #
#   source ./sdb                                                                               #
#                                                                                              #
#   if the script is somewhere else.                                                           #
#   source /path/to/somewhere/else/sdb                                                         #
################################################################################################

# ******************************************************************************************** #
#                       Enable extglob, just in case it is not enabled.                        #
# ******************************************************************************************** #

if ! builtin shopt -q extglob; then
  builtin shopt -s extglob
fi

# ******************************************************************************************** #
#                             The scriptname without the pathname.                             #
# ******************************************************************************************** #

__sdb_name_=${BASH_SOURCE##*/}

# ******************************************************************************************** #
#                    Warn function to print error messages to stderr.                          #
# ******************************************************************************************** #

__sdb_warn_() {
  builtin printf '%s: %s\n%s\n' "$__sdb_name_" "$@" >&2
}

# ******************************************************************************************** #
#                   Check if bash version is lower than 4, exit if true.                       #
# ******************************************************************************************** #

__sdb_check_bash_version () {
  if (( BASH_VERSINFO[0] < 4 )); then
    __sdb_warn_ 'This function requires bash 4.0 or newer' 'Please update to a more recent bash.'
    builtin return
  fi
}

__sdb_check_bash_version

# ******************************************************************************************** #
#       Function for , exit so sdb can capture the commands before it can be executed.         #
# ******************************************************************************************** #

exit() {
  builtin history -s -- exit "$@"
}

# ******************************************************************************************** #
#                               Function to show the help menu.                                #
# ******************************************************************************************** #

____ShowHelp____() {
  if ! builtin type -P less >/dev/null; then
    __sdb_warn_ "less is either not installed or it is not in your PATH" "bye!"
    builtin return 1
  fi
  builtin command -p less <<-'EOF'
USAGE: sdb [OPTIONS]... [QUERY]...

A bash shell function that records bash_history in a sqlite3 database.
Recorded commands can be queried and executed as well.

Without any options/arguments the default is to show the recent commands
if there is/are any in the current session. (sdb commands excluded by default.)

OPTIONS:
  -c, --common-info                     Implies -hudl.
  -?, --help                            Show this help.
  -s, --self                            Include history about sdb.
  -u, --user [word]                     Show user that matches word.
  -h, --host [word]                     Show the host that matches word.
  -E, --execute-id [n]                  Execute the command with the nth id.
  -l, --last-status                     Show the exit status of the commands.
  -e, --end-with [word]                 Match only commands that ends with word.
  -b, --begin-with [word]               Match only commands that starts with word.
  -d, --directory                       Show the working directory of the commands.
  -v, --verbose                         Verbose output (show actual sqlite3 command).
  -M, --mode-line                       Print the output as if ".mode line" is enabled.
  -w, --with-word [word]                Match commands with word from beginning to end.
  -p, --path [dir]                      Show commands executed inside the directory dir.
  -a, --all                             Include history of all sessions. Not only current.
  -o, --other-users                     Show All other users besides the current user (if any)
  -S, --shell                           Access to the sqlite3 shell and load the shell database.
  -r, --recurse-path [dir]              Show commands executed inside and under the directory dir.
  -T, --time-search-epoch [start],[end] Search commands from start date to end date (shows epoch).
  -t, --time-search [start],[end]       Search commands from start date to end date (Human readable).
  -m, --max-count [n+]                  N numbers of latest commands to show. Use + for maximum value.
  -A, --ascending                       Sort the output in an ascending manner (Descending is the default).
  -n, --numeric-status [n+]             Show commands that exited with the nth status or + if greater than zero.

  A newly open shell does not have  any commands to show unless the -a option is specified which defaults to 100
  lines, unless the -m option is specified.

DATE/TIME
  The date/time format is in Unix epoch time. GNU date(1) has some option to convert that into human readable format
  It also has an option  which allows you to say  things like  today, now, yesterday, -1 month, last year  and so on
  The -[tT] or --time-search-[epoch] make use of those words. The format is "startdate,end date" [lower|upper] bound
  It should be  separated by a comma or just "start_date". Start date should  always  come first followed by the end
  date. Both arguments needs  to be quoted together, otherwise the shell  will see it as two arguments. The end date
  can be omitted and will default to `now`, the value of `date -d'now' '+%F %T'`

EXAMPLES
  search between yesterday and now.

  "yesterday, now"

  search between yesterday and an hour ago

  "-1 day, -1 hour"

  search between a year ago and today.

  "1 year ago, today"

  search between last tuesday and a minute ago.

  "last tuesday, -1 minute"

  The -t option shows the Human readable time format because 99.9% of general Human population cannot convert the
  raw epoch time format into a human readable one without blinking an eye or twitching a muscle :-).

  See the manual for more info on GNU date(1).

QUERY
  For maximum query use + instead of [n] when the -m or --max-count is specified.
  The value of [n] becomes 999999999999999999, Which translates to:

  Nine hundred ninety-nine quadrillion.
  Nine hundred ninety-nine trillion.
  Nine hundred ninety-nine billion.
  Nine hundred ninety-nine million.
  Nine hundred ninety-nine thousand.
  Nine hundred ninety-nine.

VERBOSE OPTION
  The -v|--verbose option shows which commands/option has been given to sqlite.
  The output can pe pasted in the terminal or save in file and can be executed
  or sourced.

WILD CARD PATTERNS
  When searching  for the commands/directories one may consider using the wild cards.
  The % in sqlite is like glob * in the shell which matches everything.
  The _ in sqlite is like ? in the shell which matches any single character.

USING THE OPTIONS
  Long options that takes an argument also supports the following syntax:

  --option=argument
  --option argument

  Short options that does not take an argument can be joined as one option:

  -adlsv

  Both short and long option can be used as well.

  --option=argument -acv -m+

  Redirect the output to a file use the redirection "greater than" > sign.

  sdb -vcam+ > file

PAGER/EDITOR
  The PAGER and EDITOR  environment  variables is used/accepted when doing a
  search/query/edit for the commands. PAGER defaults to  whatever the system
  is using. EDITOR defaults to vim if empty.

  PAGER=kate sdb -vcam+

  EDITOR=nano sdb -E 101

  Some editors like gvim does not work by default without some options.
  create a function first.

  gvim() { builtin command -p gvim -f "$@"; }

  PAGER=gvim sdb -vcam+

THE FULL ORDER OF COLUMNS
   1rst column: ID column, increment of all the executed commands.
   2nd  column: Number of times the commands has been executed.
   3rd  column: Specified by -[hu], shows the user & host.
   4rth column: Date and time of the executed commands.
   5th  column: Specified by the -l option shows the exit status.
   6th  column: Shows which "tty" the commands has been executed .
   7th  column: Specified by the -d option shows the pwd.
   last column: Commands, separated by [>|▶] from the directory column.

NOTE
   As far as the shell is concern When it comes to the exit status of the given
   command, 0 is a success and the rest are a failure. But not all commands that
   exited with a nonzero is a failure per se. Likewise  not all  commands that
   exited with  zero is a success. Consult  the documentation of the program in
   question.

SEE ALSO
   sqlite3(1), signal(7), date(1)
   https://www.sqlite.org/index.html
   The "EXIT STATUS" section from bash(1).

AUTHOR
   Jason V. Ferrer <jetchisel@opensuse.org>
EOF
builtin return
}

# ******************************************************************************************** #
#                                      The magic starts.                                       #
# ******************************************************************************************** #

if "${SDB_HISTORY:-true}"; then
  if ! builtin type -P dd >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "dd is either not installed or it is not in your PATH!" >&2
    builtin return 127
  elif ! builtin type -P base64 >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "base64 is either not installed or it is not in your PATH!" >&2
    builtin return 127
  fi
  TMPDIR=${TMPDIR:-/tmp}
  __sdb_salt=$(builtin command -p dd if=/dev/urandom bs=32 count=1 2>/dev/null | builtin command -p base64)
  __sdb_initialized=0
  __sdb_pwd=$(builtin pwd)
  __sdb_pwd=${__sdb_pwd//$'\n'/\\n}
  __sdb_oldpwd+=("$__sdb_pwd")
  __sdb_empty_data_base=0
  __sdb_does_not_exists=0
  __sdb_file=${SDB_DATABASE:-"$HOME/.bash_history.sqlite"}

  if ! builtin type -P sqlite3 >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" 'sqlite3 is either not installed or it is not in your PATH' >&2
    builtin return 127
  fi
  __sdb_sqlite() {
    builtin command -p sqlite3 "$__sdb_file" "$@"
  }

  __sdb_init() {
    builtin local sql='CREATE TABLE IF NOT EXISTS history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hist_id INTEGER,
    cmd TEXT,
    epoch INTEGER,
    ppid INTEGER,
    exit_status INTEGER,
    tty TEXT,
    user_hosts TEXT,
    pwd TEXT,
    salt TEXT
    );
    CREATE TABLE IF NOT EXISTS directories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    epoch INTEGER,
    ppid INTEGER,
    user_hosts TEXT,
    cwd TEXT,
    salt TEXT
    );'

    if [[ ! -f "$__sdb_file" ]]; then
      __sdb_sqlite <<< "$sql"
    fi
  }

  if ! builtin type -P whoami >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "whoami is either not installed or it is not in your PATH!" >&2
    builtin return 127
  elif ! builtin type -P uname >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "uname is either not installed or it is not in your PATH!" >&2
    builtin return 127
  fi

  __sdb_logname_=$(builtin command -p whoami)
  __sdb_hostname_=$(builtin command -p uname -n)
  __sdb_user_host=${__sdb_logname_:-"$LOGNAME"}@${__sdb_hostname_:-"$HOST"}

# ******************************************************************************************** #
#             Save the previous/recent cwd in the directories table in a function.             #
# ******************************************************************************************** #

  __sdb_recent_pwd () {
    __sdb_sqlite "SELECT cwd FROM directories WHERE user_hosts = '$__sdb_user_host' ORDER BY ID DESC LIMIT 1;"
  }

# ******************************************************************************************** #
#   Insert into the directories table when "exec bash" or "source ~/.bashrc" etc is entered.   #
# ******************************************************************************************** #

  if [[ -f $__sdb_file && $(__sdb_recent_pwd) != $__sdb_pwd ]]; then
    __sdb_sqlite <<-EOF
	INSERT INTO directories (
	epoch, ppid, user_hosts, cwd, salt
	)
	VALUES (
	STRFTIME ('+%s', 'now'), "$PPID", "$__sdb_user_host", "${__sdb_pwd//\"/\"\"}", "$__sdb_salt"
	);
	EOF
  fi

# ******************************************************************************************** #
#                    The function that will be the value of PROMPT_COMMAND                     #
# ******************************************************************************************** #

  __sdb_prompt() {
    Last_Command=$?
    builtin history -a
    builtin history -c
    builtin history -r

    if ((!__sdb_initialized)); then
      __sdb_init
      __sdb_initialized=1
      builtin return
    fi

    if ((!__sdb_does_not_exists)); then
      if [[ ! -f $__sdb_file ]]; then
        __sdb_warn_ "It looks like $__sdb_file does not exists, please verify it." "run: file $__sdb_file"
        builtin return 1
      fi
    fi

    if ((!__sdb_empty_data_base)); then
      if [[ ! -s $__sdb_file  ]]; then
        __sdb_warn_ "It looks like $__sdb_file is empty, please verify it." "run: file $__sdb_file"
        builtin return 1
      fi
    fi

    if [[ -n $COMP_LINE ]]; then
      builtin return
    fi

# ******************************************************************************************** #
#                               Some variables for __sdb_prompt.                               #
# ******************************************************************************************** #

    builtin local IFS=
    builtin local num=
    builtin local pwd=
    builtin local pts=
    builtin local minus=
    builtin local epoch=
    builtin local total0=
    builtin local total1=
    builtin local regexp2=
    builtin local logname=
    builtin local command=
    builtin local hostname=
    builtin local command__=
    builtin local previous_pts=
    builtin local previous_cmd=
    builtin local previous_cwd=
    builtin local recent_command=
    builtin local latest_hist_id=
    builtin local status_command=
    builtin local uncaptured_pwd=
    builtin local uncaptured_num=
    builtin local uncaptured_reg=
    builtin local previous_epoch=
    builtin local uncaptured_salt=
    builtin local uncaptured_ppid=
    builtin local history2_output=
    builtin local history1_output=
    builtin local uncaptured_epoch=
    builtin local uncaptured_command=
    builtin local previous_user_hosts=
    builtin local sdb_recent_pwd=
    pts=$(builtin command -p tty) || builtin return
    pts=${pts#*dev}
    pts=${pts//\/}
    pwd=$(builtin pwd)
    pwd=${pwd//$'\n'/\\n}
    __sdb_pwd=$(builtin pwd)
    __sdb_pwd=${__sdb_pwd//$'\n'/\\n}

    if [[ ${__sdb_oldpwd[-1]} != $__sdb_pwd ]]; then
      pwd=${__sdb_oldpwd[-1]}
      __sdb_oldpwd+=("$__sdb_pwd")
    fi

# ******************************************************************************************** #
# Insert into the directories table everytime we hit ze return key. Just to know where we are. #
# ******************************************************************************************** #

  if [[ $(__sdb_recent_pwd) != $__sdb_pwd ]]; then
    __sdb_sqlite <<-EOF
	INSERT INTO directories (
	epoch, ppid, user_hosts, cwd, salt
	)
	VALUES (
	STRFTIME ('+%s', 'now'), "$PPID", "$__sdb_user_host", "${__sdb_pwd//\"/\"\"}", "$__sdb_salt"
	);
	EOF
  fi

# ******************************************************************************************** #
#  A hack to capture commands like "exec rm file" or "source  ~/.bashrc" by parsing history 2  #
# ******************************************************************************************** #

    regexp='[[:space:]]+([[:digit:]]+)[[:space:]]+([[:digit:]]+)[[:space:]](.+)'
    uncaptured_reg='^.*[[:space:]]*(source|exec)[[:space:]]+.*'
    while builtin read -r history2_output
      IFS=$'\n' builtin read -rd '' history1_output; do
      :
    done < <(builtin history 2)

    if [[ ! -s $TMPDIR/${__sdb_logname_}_sdb_last_status ]]; then
      if [[ $history2_output =~ $regexp ]]; then
        uncaptured_num=${BASH_REMATCH[1]}
        uncaptured_epoch=${BASH_REMATCH[2]}
        uncaptured_command=${BASH_REMATCH[3]}
        if [[ $uncaptured_command =~ $uncaptured_reg ]]; then
          while builtin read -r uncaptured_salt
            builtin read -r uncaptured_ppid
            builtin read -r previous_user_hosts
            builtin read -r previous_cmd
            builtin read -r previous_epoch
            builtin read -r previous_pts
            builtin read -r previous_status
            builtin read -ru8 previous_cwd; do
            break
          done < <(
            __sdb_sqlite ".sep \n" "SELECT salt,ppid,user_hosts,cmd,epoch,tty,exit_status FROM history WHERE
            user_hosts = '$__sdb_user_host' AND epoch < '$uncaptured_epoch' ORDER BY ID DESC LIMIT 1;"
            ) 8< <(
             if [[ ${previous_pts//[[:alpha:]]} -le ${pts//[[:alpha:]]} ]]; then
                __sdb_sqlite "SELECT DISTINCT cwd FROM directories WHERE
                user_hosts = '$__sdb_user_host' AND epoch < '$uncaptured_epoch' ORDER BY ID DESC LIMIT 1;"
              else
                __sdb_sqlite "SELECT DISTINCT cwd FROM directories WHERE
                user_hosts = '$__sdb_user_host' AND epoch < '$uncaptured_epoch' ORDER BY ID DESC LIMIT 1, 1;"
              fi
              )
     __sdb_sqlite <<-END
	INSERT INTO history (
	hist_id, epoch, cmd, ppid, exit_status, tty, user_hosts, pwd, salt
	)
	VALUES (
	"$uncaptured_num",
	"$uncaptured_epoch",
	"${uncaptured_command//\"/\"\"}",
	"$uncaptured_ppid",
	"0",
	"$previous_pts",
	"$__sdb_user_host",
	"${previous_cwd//\"/\"\"}",
	"$uncaptured_salt"
	);
	END
        fi
      fi
    else
      builtin command -p rm -rf "$TMPDIR/${__sdb_logname_}_sdb_last_status" || builtin return
    fi

# ******************************************************************************************** #
#                                      Parsing history 1.                                      #
# ******************************************************************************************** #

    if [[ $history1_output =~ $regexp ]]; then
      num=${BASH_REMATCH[1]}
      epoch=${BASH_REMATCH[2]}
      command=${BASH_REMATCH[3]}
    fi

    if [[ $command = 'exit '* ]]; then
      if [[ ${command#* } = +([0-9]) ]]; then
        Last_Command=${command#* }
      else
        Last_Command=2
      fi
    fi

    if [[ $command =~ $uncaptured_reg ]]; then
      builtin echo "$Last_Command" > "$TMPDIR/${__sdb_logname_}_sdb_last_status" || builtin return
    fi

    __sdb__executioner__() {
      builtin local dirname=
      builtin local basename=
      if [[ $command = 'exit '* ]]; then
        dirname=${command% *}
        basename=${command#* }
        builtin "$dirname" "$basename"
      elif [[ $command = 'exit' ]]; then
        builtin exit
      fi
    }

# ******************************************************************************************** #
#             Insert data into the database using a while read loop and a heredoc.             #
# ******************************************************************************************** #

    while builtin read -r command__ <&8; do
      __sdb_sqlite <<-END
	INSERT INTO history (
	hist_id, epoch, cmd, ppid, exit_status, tty, user_hosts, pwd, salt
	)
	VALUES (
	"${num:-$(( $(__sdb_sqlite 'SELECT hist_id FROM history ORDER BY id DESC LIMIT 1;') + 1 )) }",
	"${epoch:-"$(builtin command -p date -d 'now' '+%s')"}",
	"${command__//\"/\"\"}",
	"$PPID",
	"${Last_Command:-777}",
	"$pts",
	"$__sdb_user_host",
	"${pwd//\"/\"\"}",
	"$__sdb_salt"
	);
	END
  done 8<<< "${command:-HISTTIMEFORMAT=\"%s \"}" || builtin return

    __sdb__executioner__
    builtin unset Last_Command
  }

  sdb() {
    builtin local all=0
    builtin local end=0
    builtin local pwd=0
    builtin local Hrt=0
    builtin local zero=0
    builtin local self=0
    builtin local path=0
    builtin local rpath=0
    builtin local begin=0
    builtin local max=100
    builtin local ascend=0
    builtin local Others=0
    builtin local execute=0
    builtin local verbose=0
    builtin local offpager=0
    builtin local OnlyUser=0
    builtin local OnlyHost=0
    builtin local modeline=0
    builtin local exit_stat=0
    builtin local user_host=0
    builtin local whole_line=0
    builtin local sdb_edit=0
    builtin local time_search=0
    builtin local numeric_status=0
    builtin local G=
    builtin local R=
    builtin local dir0=
    builtin local dir1=
    builtin local dir2=
    builtin local user0=
    builtin local user1=
    builtin local user2=
    builtin local stat0=
    builtin local stat1=
    builtin local stat2=
    builtin local pwd_q=
    builtin local menus=
    builtin local answer=
    builtin local location=
    builtin local UserOnly=
    builtin local HostOnly=
    builtin local optstring=
    builtin local separator=
    builtin local User_Host=
    builtin local query_end=
    builtin local pathquery=
    builtin local rpathquery=
    builtin local ExitStatus=
    builtin local query_begin=
    builtin local query_whole=
    builtin local execute_var=
    builtin local time_search0=
    builtin local time_search1=
    builtin local time_search2=
    builtin local execute_var0=
    builtin local regexpath=[./]
    builtin local temporary_dir=
    builtin local temporary_file=
    builtin local both_user_host=
    builtin local numeric_status_value=
    builtin local to_be_executed_by_eval=
    builtin local sorting=DESC
    builtin local name=$__sdb_name_
    builtin local tty0='---------+'
    builtin local tty1='   TTY   |'
    builtin local tty2='---------+'
    builtin local comm0='----------------+'
    builtin local comm1='   COMMAND      |'
    builtin local comm2='----------------+'
    builtin local def0='+------------+--------+---------------------+'
    builtin local def1='|     ID     | COUNT  |      DATE/TIME      |'
    builtin local def2='+------------+--------+---------------------+'
    temporary_file=__${__sdb_name_}_tempfile_$RANDOM
    builtin declare -a hrt
    builtin declare -a sdb_opt
    builtin declare -a verbose_sql_commands
    builtin declare -a sql_commands
    builtin declare -a sql_commands{0..14}

    if builtin type -P tput >/dev/null; then
      G=$(builtin command -p tput bold)
      R=$(builtin command -p tput sgr0)
    fi

# ******************************************************************************************** #
# Getops from scratch by D.J. Mills, https://github.com/e36freak/templates/blob/master/options #
# ******************************************************************************************** #

    optstring=acdlosvAMSb:e:h:m:n:u:w:r:t:p:E:T:

    builtin unset options

    while (($#)); do
      case $1 in
        -[!-0-9]?*)
          for ((i=1; i<${#1}; i++)); do
            c=${1:i:1}
            options+=("-$c")
            if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
              options+=("${1:i+1}")
              builtin break
            fi
          done
          ;;
        --?*=*) options+=("${1%%=*}" "${1#*=}");;
        --) options+=(--endopts);;
        *) options+=("$1");;
      esac
      builtin shift
    done

    builtin set -- "${options[@]}"
    builtin unset options

# ******************************************************************************************** #
#   If first option is not empty and it does not start with a dash then exit with an error.    #
# ******************************************************************************************** #

    [[ -n $1 && $1 != -?* ]] && {
      __sdb_warn_ "invalid option -- '$1'" "Try '$__sdb_name_ --help'"
      builtin return 1
    }

# ******************************************************************************************** #
#                          Parse the command line arguments/options.                           #
# ******************************************************************************************** #

    while [[ $1 = -?* ]]; do
      case $1 in
        --shell|-S)
          __sdb_sqlite
          builtin return
          ;;
        --help|-\?)
          ____ShowHelp____
          builtin return
          ;;
        --max-count|-m)
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "Max count requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          elif ! [[ $1 = +([0-9]) || $1 = "+" ]]; then
            __sdb_warn_ "max count -- '$G$1$R' should be a number or a + sign!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          if [[ $1 = + ]]; then
            max=999999999999999999
          else
            max=$1
          fi
          ;;
        --ascending|-A)
          ascend=1
          ;;
        --all|-a)
          all=1
          ;;
        --common-info|-c)
          pwd=1
          user_host=1
          exit_stat=1
          ;;
        --last-status|-l)
          exit_stat=1
          ;;
        --mode-line|-M)
          modeline=1
          ;;
        --other-users|-o)
          Others=1
          ;;
        --self|-s)
          self=1
          ;;
        --begin-with|-b)
          builtin shift
          begin=1
          if ((whole_line)); then
            __sdb_warn_ 'conflicting options specified!' "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          if [[ -z $1 ]]; then
            __sdb_warn_ "begin requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          query_begin=$1
          ;;
        --host|-h)
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "host requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          Others=1
          user_host=1
          OnlyHost=1
          HostOnly=%@${1}
          ;;
        --time-search|--time-search-epoch|-T|-t)
          case $1 in
            --time-search|-t)
              Hrt=1;;
          esac
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "Time requires two values, separated by a comma!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          time_search=1
          time_search0=$1
          if [[ $time_search0 != *','* ]]; then
            time_search1=$time_search0
          elif [[ $time_search0 = *','* ]]; then
            time_search1=${time_search0%,*}
            time_search2=${time_search0#*,}
          fi
          builtin command -p date -d"${time_search0%,*}" "+%s" >/dev/null 2>&1 || {
            __sdb_warn_ "Syntax error" "invalid date -- '$G$time_search0$R'"
            builtin return 1
          }
          builtin command -p date -d"${time_search0#*,}" "+%s" >/dev/null 2>&1 || {
            __sdb_warn_ "Syntax error" "invalid date -- '$G$time_search0$R'"
            builtin return 1
          }
          ;;
        --user|-u)
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "user requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          Others=1
          user_host=1
          OnlyUser=1
          UserOnly=${1}@%
          ;;
        --end-with|-e)
          builtin shift
          end=1
          if ((whole_line)); then
            __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          if [[ -z $1 ]]; then
            __sdb_warn_ "end requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          query_end=$1
          ;;
        --recurse-path|-r)
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "path requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          elif [[ $1 =~ $regexpath ]]; then
            if builtin type -P realpath >/dev/null; then
              rpathquery=$(builtin command -p realpath -- "$1")
            else
              __sdb_warn_ "Could not resolve path $G$1$R" "realpath is either not installed or it is not in your PATH"
              builtin return 1
            fi
          else
            rpathquery=$1
          fi
          rpath=1
          pwd=1
          ;;
        --path|-p)
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "path requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          elif [[ $1 =~ $regexpath ]]; then
            if builtin type -P realpath >/dev/null; then
              pathquery=$(builtin command -p realpath -- "$1")
            else
              __sdb_warn_ "Could not resolve path $G$1$R" "realpath is either not installed or it is not in your PATH"
              builtin return 1
            fi
          else
            pathquery=$1
          fi
          pwd=1
          path=1
          ;;
        --verbose|-v)
          verbose=1
          ;;
        --with-word|-w)
          builtin shift
          whole_line=1
          if ((begin || end)); then
            __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          if [[ -z $1 ]]; then
            __sdb_warn_ "word requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          query_whole=$1
          ;;
        --execute-id|-E)
          builtin shift
          execute=1
          if [[ -z $1 ]]; then
            __sdb_warn_ "id requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          elif [[ $1 != +([0-9]) ]]; then
            __sdb_warn_ "id -- '$G$1$R' should be a number!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          execute_var=$1
          ;;
        --directory|-d)
          pwd=1
          ;;
        --numeric-status|-n)
          builtin shift
          if [[ -z $1 ]]; then
            __sdb_warn_ "status requires a value!" "Try '$__sdb_name_ --help'"
            builtin return 1
          elif ! [[  $1 = +([0-9]) || $1 = + ]]; then
            __sdb_warn_ "status requires an integer or a + sign!" "Try '$__sdb_name_ --help'"
            builtin return 1
          fi
          exit_stat=1
          numeric_status=1
          numeric_status_value=$1
          ;;
        --endopts)
          builtin shift
          builtin break
          ;;
        *)
           __sdb_warn_ "invalid option -- '$G$1$R'" "Try '$__sdb_name_ --help'"
           builtin return 1
          ;;
      esac
      builtin shift
    done

# ******************************************************************************************** #
#            The separator character to print, depending on the value of $DISPLAY.             #
# ******************************************************************************************** #

    if [[ -n $DISPLAY ]]; then
      separator=' ▶  '
    else
      separator=' >  '
    fi

# ******************************************************************************************** #
#       How do I create a temporary file in a secure manner?, see wiki.wooledge/FAQ/062        #
# ******************************************************************************************** #

    builtin trap 'builtin command -p rm -rf -- "$temporary_dir"' return
    builtin trap 'builtin return 1 >/dev/null 2>&1' 1 2 3 15
    temporary_dir=$(builtin command -p mktemp -d "$TMPDIR/sdb.XXXXXXXXXXXXXXXXXXXXXXXXXXXXX") || {
      builtin printf 'ERROR creating a temporary files\n' >&2
      builtin return 1
    }

# ******************************************************************************************** #
# Run the command with the corresponding ID, with the all time favorite builtin command: EVAL  #
# ******************************************************************************************** #

    if ((execute)); then
      execute_var0=$(__sdb_sqlite "select cmd,exit_status from history where id in ( $execute_var );")
      if [[ -z $execute_var0 ]]; then
        __sdb_warn_ "id -- \`$G$execute_var$R' is either out of range, or it has no command." "Try another number instead!" >&2
        builtin return 1
      fi

      sdb_opt=(
        "[Execute the command]${separator// } \`$G${execute_var0%"|"*}$R'" "[Previous exit_status]${separator// } \`$G${execute_var0##*"|"}$R'"
        "[Inside the current directory]${separator// } \`$G$(builtin pwd)$R'" "${G}1${R}) Yes, execute now." "${G}2${R}) No, abort command."
        "${G}3${R}) No, print ALL info to stdout only." "${G}4${R}) No, edit command first with the EDITOR." "[${G}1-4${R}]$G${separator// }$R "
      )

       while builtin :; do
         builtin printf -v menus '\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n%s%s' "${sdb_opt[@]}"
         builtin read -rp "$menus" -n 1 answer
          case $answer in
            1)
              builtin echo
              { [[ -d "${execute_var0%"|"*}" ]] && builtin shopt -q autocd ; } || builtin printf '%s\n' "${execute_var0%"|"*}"
              builtin history -s "${execute_var0%"|"*}"
              builtin eval "${execute_var0%"|"*}" || builtin return
              builtin return
              ;;
            2) builtin return
              ;;
            3)
              builtin echo
              __sdb_sqlite ".mode line" "select * from history where id = $execute_var;"
              builtin return
              ;;
            4)
              builtin echo
              sdb_edit=1
              builtin break
              ;;
            *)
              builtin printf '\n\n'
              __sdb_warn_ "invalid option -- '$G$answer$R'" "Try '[${G}1 2 3 4${R}]'"
              builtin return 1
              ;;
          esac
      done

      if ((sdb_edit)); then
        builtin printf '%s\n' "${execute_var0%"|"*}" > "$temporary_dir/$temporary_file" 2>&1 || builtin return
        "${EDITOR:-vim}" -- "$temporary_dir/$temporary_file" || builtin return
        while IFS= builtin read -u9 -r to_be_executed_by_eval; do
          builtin history -s "$to_be_executed_by_eval"
          { [[ -d "$to_be_executed_by_eval" ]] && builtin shopt -q autocd ; } || builtin printf '%s\n' "$to_be_executed_by_eval"
          builtin eval "$to_be_executed_by_eval" || builtin return
        done 9< "$temporary_dir/$temporary_file" || builtin return
        builtin return
      fi
    fi

# ******************************************************************************************** #
#      First sqlite3 command, just to print out a formatted output separated by a pipe.        #
# ******************************************************************************************** #

    if ((exit_stat)); then
      ExitStatus="substr ('      '||max(exit_status),-6) || ' | ' ||"
      stat0='--------+'
      stat1=' STATUS |'
      stat2='--------+'
    fi

    if ((user_host)); then
      User_Host="substr ('             '||max(user_hosts),-20) || ' | ' ||"
      user0='----------------------+'
      user1='      USER@HOST       |'
      user2='----------------------+'
    fi

    if ((pwd)); then
      pwd_q="pwd || '$separator' ||"
    fi

    if ((modeline)); then
      first_sql_commands=".mode line
        SELECT * FROM history WHERE 1"
    else
      first_sql_commands="
       SELECT
         substr ('           '||max(id),-12) || ' | ' ||
         substr ('      '||count(*),-6) || ' | ' ||
         datetime (max (epoch), 'unixepoch', 'localtime') || ' | ' ||
         $User_Host
         $ExitStatus
         substr ('        '||max(tty),-7) || ' | ' ||
         $pwd_q"
    fi

# ******************************************************************************************** #
#     Sqlite3 commands to be executed depending on the args/options given by the user.         #
# ******************************************************************************************** #

    if ((!modeline)); then
      sql_commands0=("cmd FROM history WHERE 1")
    fi

    if ((!all)); then
      sql_commands1=("AND (salt='$__sdb_salt' AND ppid='$PPID')")
    fi

    if ((!Others)); then
      sql_commands2=("AND (user_hosts = '$__sdb_user_host')")
    fi

    if ((!self)); then
      sql_commands3=("AND (cmd != 'sdb' AND cmd NOT LIKE 'sdb %')")
    fi

    if ((OnlyUser)); then
      sql_commands4=("AND (user_hosts LIKE '$UserOnly')")
    fi

    if ((OnlyHost)); then
      sql_commands5=("AND (user_hosts LIKE '$HostOnly')")
    fi

    if ((begin)); then
      query_begin=${query_begin//\"/\"\"}
      query_begin=$query_begin%
      sql_commands6=("AND (cmd LIKE '$query_begin' ESCAPE '\')")
    fi

    if ((end)); then
      query_end=${query_end//\"/\"\"}
      query_end=%$query_end
      sql_commands7=("AND (cmd LIKE '$query_end' ESCAPE '\')")
    fi

    if ((whole_line)); then
      query_whole=${query_whole//\"/\"\"}
      query_whole=%$query_whole%
      sql_commands8=("AND (cmd LIKE '$query_whole' ESCAPE '\')")
    fi

    if ((path)); then
      if [[ -n $rpathquery ]]; then
        __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
        builtin return 1
      fi
      pathquery=${pathquery//\"/\"\"}
      sql_commands9=("AND (pwd = '$pathquery')")
    fi

    if ((rpath)); then
       if [[ -n $pathquery ]]; then
         __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
         builtin return 1
       fi
       rpathquery=${rpathquery//\"/\"\"}
      sql_commands10=("AND (pwd LIKE '$rpathquery%' ESCAPE '\')")
    fi

    if ((numeric_status)); then
      if [[ $numeric_status_value = + ]]; then
        sql_commands11=("AND (exit_status > '0')")
      else
        sql_commands11=("AND (exit_status = '$numeric_status_value')")
      fi
    fi

    if ((time_search && ! Hrt)); then
      sql_commands12=(
        "AND (epoch BETWEEN $(builtin command -p date -d"$time_search1" "+%s") AND $(builtin command -p date -d"${time_search2:-now}" "+%s"))"
        )
     fi

     if ((time_search && Hrt)); then
       sql_commands12=(
        "AND date(datetime(epoch, 'unixepoch', 'localtime'))
         BETWEEN date('$(builtin command -p date -d"$time_search1" "+%F %T")')
           AND   date('$(builtin command -p date -d"${time_search2:-now}" "+%F %T")')"
       )
    fi

    sql_commands13=("GROUP BY cmd,exit_status,tty,user_hosts")
    if ((pwd)); then
      sql_commands14=(,pwd)
      dir0='----------------+'
      dir1="   DIRECTORY    |${separator// }"
      dir2='----------------+'
      comm1='    COMMAND    |'
    fi

    if ((ascend)); then
      sorting=ASC
    fi

    sql_commands15=("ORDER BY max(id) $sorting LIMIT $max;")

    sql_commands=(
      "$first_sql_commands" "${sql_commands0[@]}" "${sql_commands1[@]}" "${sql_commands2[@]}"
      "${sql_commands3[@]}" "${sql_commands4[@]}" "${sql_commands5[@]}" "${sql_commands6[@]}"
      "${sql_commands7[@]}" "${sql_commands8[@]}" "${sql_commands9[@]}" "${sql_commands10[@]}"
      "${sql_commands11[@]}" "${sql_commands12[@]}" "${sql_commands13[@]}" "$sql_commands14"
      "${sql_commands15[@]}"
    )

    if ((modeline)); then
      first_sql_commands=" ${first_sql_commands/".mode line"/'".mode line" "'}"
    else
      first_sql_commands=" \"$first_sql_commands"
    fi

    verbose_sql_commands=(
      "$first_sql_commands" "${sql_commands0[@]}" "${sql_commands1[@]}" "${sql_commands2[@]}"
      "${sql_commands3[@]}" "${sql_commands4[@]}" "${sql_commands5[@]}" "${sql_commands6[@]}"
      "${sql_commands7[@]}" "${sql_commands8[@]}" "${sql_commands9[@]}" "${sql_commands10[@]}"
      "${sql_commands11[@]}" "${sql_commands12[@]}" "${sql_commands13[*]}$sql_commands14"
      "${sql_commands15[@]/%/\"}"
    )

    if ((verbose)); then  ## You can literally copypaste/save this verbose output in a file and run/execute/source the file.
      {
        builtin printf '%s %s' "sqlite3" "$__sdb_file"
        builtin printf '%s\n' "${verbose_sql_commands[@]}"
        builtin printf '\n'
      } >> "$temporary_dir/$temporary_file" || builtin return
    fi

    if ((!modeline)); then
      {
        builtin printf '%s\n%s\n%s\n' "$def0$user0$stat0$tty0$dir0$comm0" "$def1$user1$stat1$tty1$dir1$comm1" "$def2$user2$stat2$tty2$dir2$comm2"
      } >> "$temporary_dir/$temporary_file" || builtin return
    fi

    __sdb_sqlite <<< "${sql_commands[@]}" >> "$temporary_dir/$temporary_file" 2>&1 || builtin return

    if [[ $PAGER  = less ]]; then
      builtin command -p "$PAGER" -Ss -- "$temporary_dir/$temporary_file" || builtin return
      builtin return
    fi
    "${PAGER:-less}" -- "$temporary_dir/$temporary_file" || builtin return
    builtin return
  }
fi

# ******************************************************************************************** #
#          assign the function __sdb_prompt to the bash variable PROMPT_COMMAND.               #
# ******************************************************************************************** #

if [[ $PROMPT_COMMAND != *__sdb_prompt* ]]; then
  PROMPT_COMMAND="__sdb_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
fi

# ******************************************************************************************** #
#   A hack to send an error message when the script was invoke via the likes of 'bash ./sdb'   #
# ******************************************************************************************** #

(builtin return 2>/dev/null) || {
  __sdb_warn_ "To use '$__sdb_name_'" "Run: source $BASH_SOURCE"
  (builtin return 2>/dev/null)
}
# vim:ft=sh
# ============================================================================================ #
#                                   >>> END OF SCRIPT <<<                                      #
# ============================================================================================ #
