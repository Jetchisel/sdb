# ============================================================================================ #
#: Title           : sdb                                                                       #
#: Sypnosis        : sdb [OPTIONS]... [QUERY]...                                               #
#: Date Created    : Sat 25 Nov 2017 10:10:47 AM +08  /  Sat Nov 25 02:10:47 UTC 2017          #
#: Last Edit       : Mon 30 Jul 2018 07:12:53 AM +08  /  Sun Jul 29 23:12:53 UTC 2018          #
#: License         : MIT                                                                       #
#: Version         : 2.6.8                                                                     #
#: Maintainer      : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : Log bash_history in a database (A fork of dbhist.sh by Dennis Gladkikh)   #
#: Options         : [abcdehlmnoprsuvwBES?]                                                    #
#: Home Page       : https://github.com/Jetchisel/sdb                                          #
#: ExtComm         : base64,date,dd,less,mktemp,whoami,realpath,rm,sqlite3,tput,uname,vim      #
#: Copyright       : Jason V. Ferrer 2017-2018                                                 #
# ============================================================================================ #

################################################################################################
# The MIT License                                                                              #
# SPDX short identifier: MIT                                                                   #
#                                                                                              #
# Further resources on the MIT License                                                         #
# Copyright 2017 Denis Gladkikh (https://www.outcoldman.com/en/archive/2017/07/19/dbhist/)     #
# Copyright 2017-2018 Jason V. Ferrer based on above.                                          #
#                                                                                              #
# Permission is hereby granted, free of charge, to any person obtaining a copy                 #
# of this software and associated documentation files (the "Software"), to deal                #
# in the Software without restriction, including without limitation the rights                 #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                    #
# copies of the Software, and to permit persons to whom the Software is                        #
# furnished to do so, subject to the following conditions:                                     #
#                                                                                              #
# The above copyright notice and this permission notice shall be included in                   #
# all copies or substantial portions of the Software.                                          #
#                                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                #
# SOFTWARE.                                                                                    #
#                                                                                              #
#==============================================================================================#
# Configuration:                                                                               #
#   Add the following entry in your shell rc file, e.g. "$HOME/.bashrc"                        #
#                                                                                              #
#   set -o history                                                                             #
#   HISTSIZE=1000                                                                              #
#   HISTTIMEFORMAT="%s "                                                                       #
#   HISTFILE=$HOME/.bash_history                                                               #
#   HISTCONTROL=ignorespace:erasedups                                                          #
#   SDB_HISTORY=true                                                                           #
#   SDB_DATABASE=$HOME/.bash_history.sqlite.                                                   #
#                                                                                              #
#   Change The value of SDB_HISTORY from "true" to "false" to disable sdb.                     #
#   Change the value of SDB_DATABASE to something/somewhere else for multi-user set up.        #
#                                                                                              #
# Using the script:                                                                            #
#   if the script is in the current pwd.                                                       #
#   source ./sdb                                                                               #
#                                                                                              #
#   if the script is somewhere else.                                                           #
#   source /path/to/somewhere/else/sdb                                                         #
################################################################################################

# ******************************************************************************************** #
#                       Enable extglob, just in case it is not enabled.                        #
# ******************************************************************************************** #

if ! builtin shopt -q extglob; then
  builtin shopt -s extglob
fi

# ******************************************************************************************** #
#                             The scriptname without the pathname.                             #
# ******************************************************************************************** #

__sdb_name_=${BASH_SOURCE##*/}

# ******************************************************************************************** #
#                    Warn function to print error messages to stderr.                          #
# ******************************************************************************************** #

__sdb_warn_() {
  builtin printf '%s: %s\n%s\n' "$__sdb_name_" "$@" >&2
}

# ******************************************************************************************** #
#              Check if bash version is lower than 4, exit with an error if true.              #
# ******************************************************************************************** #

if (( BASH_VERSINFO[0] < 4 )); then
  __sdb_warn_ 'This function requires bash 4.0 or newer' 'Please update to a more recent bash.'
  return 1
fi

# ******************************************************************************************** #
#       Function for , exit so sdb can capture the commands before it can be executed.         #
# ******************************************************************************************** #

exit() {
  builtin history -s -- exit "$@"
}

# ******************************************************************************************** #
#                               Function to show the help menu.                                #
# ******************************************************************************************** #

____ShowHelp____() {
  if ! type -P less >/dev/null; then
    __sdb_warn_ "less is either not installed or it is not in your PATH" "bye!"
    builtin return 1
  fi
  less -Ss <<-EOF
USAGE: $__sdb_name_ [OPTIONS]... [QUERY]...

A bash shell function that records bash_history in a sqlite3 database.
Recorded commands can be queried and executed as well.

Without any options/arguments the default is to show the recent commands
if there is/are any in the current session. ($__sdb_name_ commands excluded by default.)

OPTIONS:
  -c, --common-info                 Implies -hudl.
  -?, --help                        Show this help.
  -s, --self                        Include history about $__sdb_name_.
  -u, --user [word]                 Show user that matches word.
  -h, --host [word]                 Show the host that matches word.
  -E, --execute-id [n]              Execute the command with the nth id.
  -l, --last-status                 Show the exit status of the commands.
  -e, --end-with [word]             Match only commands that ends with word.
  -o, --off-pager                   Disable the pager. (not for -? and --help)
  -b, --begin-with [word]           Match only commands that starts with word.
  -d, --directory                   Show the working directory of the commands.
  -v, --verbose                     Verbose output (show actual sqlite3 command).
  -w, --with-word [word]            Match commands with word from beginning to end.
  -p, --path [dir]                  Show commands executed inside the directory dir.
  -a, --all                         Include history of all sessions. Not only current.
  -S, --shell                       Access to the sqlite3 shell and load the shell database.
  -r, --recurse-path [dir]          Show commands executed inside and under the directory dir.
  -t, --time-search [start],[end]   Search commands from start date to end date, GNU date syntax.
  -m, --max-count [n+]              N numbers of latest commands to show. Use + for maximum value.
  -n, --numeric-status [n+]         Show commands that exited with the nth status or + if greater than zero.

A newly open shell does not have  any commands to show unless the -a option is specified which
defaults to 100 lines, unless the -m option is specified.

The date/time format is in Unix epoch time. GNU date has some option to convert that into human
readable format. It also has an option which allows you to say things like today, now, yesterday
-1 month, etc. The -t or --time-search make use of this words. The format is \"startdate, end date\"
It should be separated by a comma. The start date should always come first followed by the end date.
Both arguments needs to be quoted together, otherwise the shell will see it as two arguments.

Examples of searching by date.

   search between yesterday and now.

    "yesterday, now"

   search between yesterday and an hour ago

   "-1 day, -1 hour"

   search between a year ago and today.

   "1 year ago, today"

   search between last tuesday and a minute ago.

   "last tuesday, -1 minute"

See the manual for more info on GNU date(1).

For maximum query use + instead of [n] when the -m or --max-count is specified.
The value of [n] becomes 999999999999999999, Which translates to:

    Nine hundred ninety-nine quadrillion.
    Nine hundred ninety-nine trillion.
    Nine hundred ninety-nine billion.
    Nine hundred ninety-nine million.
    Nine hundred ninety-nine thousand.
    Nine hundred ninety-nine.

Long options that takes an argument also supports the following syntax:

    --option=argument

Short options that does not take an argument can be joined as one option:

    -adlsv

Both short and long option can be used as well.

    --option=argument -acv -m+

Redirect the output to a file use the redirection "greater than" > sign.

    sdb -vcam+ > file

The PAGER and EDITOR  environment  variables is used/accepted when doing a
search/query/edit for the commands. Except for -? and --help option. PAGER
defaults to  whatever the system is using. EDITOR defaults to vim if empty.

    PAGER=kate sdb -vcam+

    EDITOR=nano sdb -E 101

Some editors like gvim does not work by default without some options.
create a function first.

    gvim() { builtin command -p gvim -f "\$@"; }

    EDITOR=gvim sdb -vcam+

THE ORDER OF COLUMNS
   1rst column: ID column, increment of all the executed commands.
   2nd  column: Number of times the commands has been executed.
   3rd  column: Specified by -[hu], shows the user & host.
   4rth column: Date and time of the executed commands.
   5th  column: Specified by the -l option shows the exit status.
   6th  column: Specified by the -d option shows the pwd.
   last column: Commands, separated by a > from the path column.

NOTE
   As far as the shell is concern When it comes to the exit status of the given
   command, 0 is a success and the rest are a failure. But not all commands that
   exited with a nonzero is a failure per se. Likewise  not all  commands that
   exited with  zero is a success. Consult  the documentation of the program in
   question.

SEE ALSO
       sqlite3(1), signal(7), date(1)
       https://www.sqlite.org/index.html
       The "EXIT STATUS" section from bash(1).

AUTHOR
     Jason V. Ferrer <jetchisel@opensuse.org>
EOF
builtin return
}

# ******************************************************************************************** #
#                                      The magic starts.                                       #
# ******************************************************************************************** #

if "${SDB_HISTORY:-true}"; then

  if ! builtin type -P dd >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "dd is either not installed or it is not in your PATH!" >&2
    builtin return 127
  elif ! builtin type -P base64 >/dev/null; then
    builtin printf '%s: %s\n' "$__sdb_name_" "base64 is either not installed or it is not in your PATH!" >&2
    builtin return 127
  else
    __sdb_salt=$(builtin command dd if=/dev/urandom bs=32 count=1 2>/dev/null | builtin command base64)
  fi

  __sdb_initialized=0

  IFS= builtin read -u7 -r __sdb_pwd 7< <(builtin pwd)
  __sdb_oldpwd+=("$__sdb_pwd")

  __sdb_empty_data_base=0
  __sdb_does_not_exists=0

  __sdb_file=${SDB_DATABASE:-$HOME/.bash_history.sqlite}

  if builtin type -P sqlite3 >/dev/null; then
    __sdb_sqlite() {
      builtin command -p sqlite3 "$__sdb_file" "$@"
    }
  else
    builtin printf '%s: %s\n' "$__sdb_name_" 'sqlite3 is either not installed or it is not in your PATH' >&2
    builtin return 127
  fi

  __sdb_init() {
    builtin local sql='CREATE TABLE history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hist_id INTEGER,
    cmd TEXT,
    epoch INTEGER,
    ppid INTEGER,
    exit_status INTEGER,
    user_hosts TEXT,
    pwd TEXT,
    salt TEXT
    );'

    if [[ ! -f "$__sdb_file" ]]; then
      __sdb_sqlite <<< "$sql"
    fi
  }


  __sdb_prompt() {
    Last_Command=$?

    if ((!__sdb_initialized)); then
      __sdb_init
      __sdb_initialized=1
      builtin return
    fi

    if ((!__sdb_does_not_exists)); then
      if [[ ! -f $__sdb_file ]]; then
        __sdb_warn_ "It looks like $__sdb_file does not exists, please verify it." "run: file $__sdb_file"
        __sdb_does_not_exists=1
        builtin return 1
      fi
    fi

    if ((!__sdb_empty_data_base)); then
      if [[ ! -s $__sdb_file  ]]; then
        __sdb_warn_ "It looks like $__sdb_file is empty, please verify it." "run: file $__sdb_file"
        __sdb_empty_data_base=1
        builtin return 1
      fi
    fi

    if [[ -n $COMP_LINE ]]; then
      builtin return
    fi

    __sdb_user_host=
    builtin local IFS=
    builtin local num=
    builtin local minus=
    builtin local epoch=
    builtin local total0=
    builtin local total1=
    builtin local regexp2=
    builtin local logname=
    builtin local command=
    builtin local hostname=
    builtin local command__=
    builtin local recent_command=
    builtin local latest_hist_id=
    builtin local two=2
    builtin local pwd=$(builtin pwd)

    if builtin type -P whoami >/dev/null; then
      logname=$(builtin command -p whoami)
    fi
    if builtin type -P uname >/dev/null; then
      hostname=$(builtin command -p uname -n)
    fi

    __sdb_user_host=${logname:-Anonymous}@${hostname:-Nohost}

    IFS= builtin read -u4 -r __sdb_pwd 4< <(builtin pwd)
    if [[ ${__sdb_oldpwd[-1]} != "$__sdb_pwd" ]]; then
      pwd=${__sdb_oldpwd[-1]}
      __sdb_oldpwd+=("$__sdb_pwd")
    fi

# ******************************************************************************************** #
# Set IFS to a newline, use reads -d option, so multiline command such a heredocs is captured. #
# ******************************************************************************************** #

    regexp='[[:space:]]+([[:digit:]]+)[[:space:]]+([[:digit:]]+)[[:space:]](.+)'
    IFS=$'\n' builtin read -u6 -rd '' recent_command 6< <(builtin history 1)

    if [[ $recent_command =~ $regexp ]]; then
      num=${BASH_REMATCH[1]}
      epoch=${BASH_REMATCH[2]}
      command=${BASH_REMATCH[3]}
    fi

    if [[ $command = 'exit '* ]]; then
      if [[ ${command#* } = +([0-9]) ]]; then
        Last_Command=${command#* }
      else
        Last_Command=2
      fi
    fi

    __sdb__executioner__() {
      local basename dirname
      if [[ $command = 'exit '* ]]; then
        dirname=${command% *}
        basename=${command#* }
        builtin "$dirname" "$basename"
      elif [[ $command = 'exit' ]]; then
        builtin exit
      fi
    }

# ******************************************************************************************** #
#             Insert data into the database using a while read loop and a heredoc.             #
# ******************************************************************************************** #

latest_hist_id=$(( $(__sdb_sqlite 'select hist_id from history order by id desc limit 1;') + 1 ))

while builtin read -r command__ <&8; do
    __sdb_sqlite <<-END
INSERT INTO history(
    hist_id, epoch, cmd, ppid, exit_status, user_hosts, pwd, salt
  )
VALUES(
    "${num:-"$latest_hist_id"}",
    "${epoch:-"$(builtin command -p date -d 'now' '+%s')"}",
    "${command__//\"/\"\"}",
    "$PPID",
    "${Last_Command:-777}",
    "$__sdb_user_host",
    "${pwd//\"/\"\"}",
    "$__sdb_salt"
  );
END
done 8<<< "${command:-HISTTIMEFORMAT=\"%s \"}"

  __sdb__executioner__
}

  sdb() {

# ******************************************************************************************** #
#                         Local variables from sdb prompt function.                            #
# ******************************************************************************************** #

     builtin local all=0
     builtin local end=0
     builtin local pwd=0
     builtin local zero=0
     builtin local self=0
     builtin local path=0
     builtin local rpath=0
     builtin local begin=0
     builtin local max=100
     builtin local execute=0
     builtin local verbose=0
     builtin local offpager=0
     builtin local OnlyUser=0
     builtin local OnlyHost=0
     builtin local exit_stat=0
     builtin local user_host=0
     builtin local whole_line=0
     builtin local __sdb_edit=0
     builtin local time_search=0
     builtin local numeric_status=0
     builtin local G=
     builtin local R=
     builtin local dir0=
     builtin local dir1=
     builtin local dir2=
     builtin local user0=
     builtin local user1=
     builtin local user2=
     builtin local stat0=
     builtin local stat1=
     builtin local stat2=
     builtin local pwd_q=
     builtin local menus=
     builtin local answer=
     builtin local location=
     builtin local UserOnly=
     builtin local HostOnly=
     builtin local optstring=
     builtin local separator=
     builtin local User_Host=
     builtin local query_end=
     builtin local pathquery=
     builtin local rpathquery=
     builtin local ExitStatus=
     builtin local query_begin=
     builtin local query_whole=
     builtin local execute_var=
     builtin local time_search0=
     builtin local time_search1=
     builtin local time_search2=
     builtin local execute_var0=
     builtin local both_user_host=
     builtin local __sdb_execute_var=
     builtin local first_sql_commands=
     builtin local numeric_status_value=
     builtin local name=$__sdb_name_
     builtin local comm0='----------------+'
     builtin local comm1='   COMMAND      |'
     builtin local comm2='----------------+'
     builtin local def0='+------------+--------+---------------------+'
     builtin local def1='|     ID     | COUNT  |      DATE/TIME      |'
     builtin local def2='+------------+--------+---------------------+'
     builtin declare -a __sdb_opt

     if builtin type -P tput >/dev/null; then
       G=$(builtin command -p tput bold)
       R=$(builtin command -p tput sgr0)
     fi

# ******************************************************************************************** #
# Getops from scratch by D.J. Mills, https://github.com/e36freak/templates/blob/master/options #
# ******************************************************************************************** #

     optstring=acdlosvSb:e:h:m:n:u:w:r:t:p:E:

     builtin unset options

     while (($#)); do
       case $1 in

         -[!-]?*)
           [[ $1 = -[[:digit:]]* ]] && options+=("$1") && shift

           for ((i=1; i<${#1}; i++)); do
             c=${1:i:1}

             options+=("-$c")

             if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
               options+=("${1:i+1}")
               builtin break
             fi
           done
           ;;

         --?*=*) options+=("${1%%=*}" "${1#*=}");;

         --) options+=(--endopts);;

         *) options+=("$1");;
       esac
       builtin shift
     done

     builtin set -- "${options[@]}"

     builtin unset options

# ******************************************************************************************** #
#   If first option is not empty and it does not start with a dash then exit with an error.    #
# ******************************************************************************************** #

     [[ -n $1 && $1 != -?* ]] && {
       __sdb_warn_ "invalid option -- '$1'" "Try '$__sdb_name_ --help'"
       builtin return 1
     }

# ******************************************************************************************** #
#                          Parse the command line arguments/options.                           #
# ******************************************************************************************** #

     while [[ $1 = -?* ]]; do
       case $1 in
         --shell|-S)
           __sdb_sqlite
           builtin return
           ;;
         --help|-\?)
           ____ShowHelp____
           builtin return
           ;;
         --max-count|-m)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "Max count requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif ! [[ $1 = +([0-9]) || $1 = "+" ]]; then
             __sdb_warn_ "max count -- '$G$1$R' should be a number or a + sign!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ $1 = + ]]; then
             max=999999999999999999
           else
             max=$1
           fi
           ;;
         --all|-a)
           all=1
           ;;
         --common-info|-c)
           pwd=1
           user_host=1
           exit_stat=1
           ;;
         --last-status|-l)
           exit_stat=1
           ;;
         --self|-s)
           self=1
           ;;
         --begin-with|-b)
           builtin shift
           begin=1
           if ((whole_line)); then
             __sdb_warn_ 'conflicting options specified!' "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ -z $1 ]]; then
             __sdb_warn_ "begin requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           query_begin=$1
           ;;
         --host|-h)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "host requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           user_host=1
           OnlyHost=1
           HostOnly=%@${1}
           ;;
         --time-search|-t)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "Time requires two values, separated by a comma!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           time_search=1
           time_search0=$1
           time_search1=$(builtin command -p date -d"${time_search0%,*}" "+%s") || builtin return
           time_search2=$(builtin command -p date -d"${time_search0#*,}" "+%s") || builtin return
           ;;
         --user|-u)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "user requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           user_host=1
           OnlyUser=1
           UserOnly="${1}@%"
           ;;
         --end-with|-e)
           builtin shift
           end=1
           if ((whole_line)); then
             __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ -z $1 ]]; then
             __sdb_warn_ "end requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           query_end=$1
           ;;
         --off-pager|-o)
           offpager=1
           ;;
         --recurse-path|-r)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "path requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif [[ $1 = @('.'|'./'|'..'|'../') ]]; then
             if type -P realpath >/dev/null; then
               rpathquery=$(builtin command -p realpath -- "$1")
             else
               __sdb_warn_ "Could not resolv path $G$1$R" "realpath is either not installed or it is not in your PATH"
               builtin return 1
             fi
           else
             rpathquery=$1
           fi
           rpath=1
           pwd=1
           ;;
         --path|-p)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "path requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif [[ $1 = @('.'|'./'|'..'|'../') ]]; then
             if type -P realpath >/dev/null; then
               pathquery=$(builtin command -p realpath -- "$1")
             else
               __sdb_warn_ "Could not resolv path $G$1$R" "realpath is either not installed or it is not in your PATH"
               builtin return 1
             fi
           else
             pathquery=$1
           fi
           pwd=1
           path=1
           ;;
         --verbose|-v)
           verbose=1
           ;;
         --with-word|-w)
           builtin shift
           whole_line=1
           if ((begin || end)); then
             __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           if [[ -z $1 ]]; then
             __sdb_warn_ "word requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           query_whole=$1
           ;;
         --execute-id|-E)
           builtin shift
           execute=1
           if [[ -z $1 ]]; then
             __sdb_warn_ "id requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif [[ $1 != +([0-9]) ]]; then
             __sdb_warn_ "id -- '$G$1$R' should be a number!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           execute_var=$1
           ;;
         --directory|-d)
           pwd=1
           ;;
         --numeric-status|-n)
           builtin shift
           if [[ -z $1 ]]; then
             __sdb_warn_ "status requires a value!" "Try '$__sdb_name_ --help'"
             builtin return 1
           elif ! [[  $1 = +([0-9]) || $1 = + ]]; then
             __sdb_warn_ "status requires an integer or a + sign!" "Try '$__sdb_name_ --help'"
             builtin return 1
           fi
           exit_stat=1
           numeric_status=1
           numeric_status_value=$1
           ;;
         --endopts)
           builtin shift
           builtin break
           ;;
         *)
            __sdb_warn_ "invalid option -- '$G$1$R'" "Try '$__sdb_name_ --help'"
            builtin return 1
           ;;
       esac
       builtin shift
     done

# ******************************************************************************************** #
#            The separator character to print, depending on the value of $DISPLAY.             #
# ******************************************************************************************** #

     if [[ -n $DISPLAY ]]; then
       separator=" ▶  "
     else
       separator=" >  "
     fi

# ******************************************************************************************** #
# Run the command with the corresponding ID, with the all time favorite builtin command: EVAL  #
# ******************************************************************************************** #

     if ((execute)); then
       execute_var0=$(__sdb_sqlite "select cmd,exit_status from history where id in ( $execute_var );")
       if [[ -z $execute_var0 ]]; then
         __sdb_warn_ "id -- \`$G$execute_var$R' is either out of range, or it has no command." "Try another number instead!" >&2
         builtin return 1
       fi

       __sdb_opt=(
         "[Execute the command]${separator// } \`$G${execute_var0%"|"*}$R'" "[Previous exit_status]${separator// } \`$G${execute_var0##*"|"}$R'"
         "[Inside the current directory]${separator// } \`$G$(builtin pwd)$R'" "${G}1${R}) Yes, execute now." "${G}2${R}) No, abort command."
         "${G}3${R}) No, print to stdout only." "${G}4${R}) No, edit command first with the EDITOR." "[${G}1-4${R}]$G${separator// }$R "
       )

        while :; do
          builtin printf -v menus  '\n%s\n%s\n%s\n\n%s\n%s\n%s\n%s\n\n%s%s' "${__sdb_opt[@]}"
          builtin read -rp "$menus" -n 1 answer
           case $answer in
             1)
               builtin echo
               { [[ -d "${execute_var0%"|"*}" ]] && builtin shopt -q autocd ; } || printf '%s\n' "${execute_var0%"|"*}"
               builtin history -s "${execute_var0%"|"*}"
               builtin eval "${execute_var0%"|"*}" || builtin return
               builtin return
               ;;
             2) builtin return
               ;;
             3)
               builtin printf '\n\n%s\n' "${execute_var0%"|"*}"
               builtin return
               ;;
             4)
               builtin echo
               __sdb_edit=1
               builtin break
               ;;
             *)
               printf '%s\n\n' "${blank+""}"
               __sdb_warn_ "invalid option -- '$G$answer$R'" "Try '[${G}1 2 3 4${R}]'"
               builtin return 1
               ;;
           esac
       done

       builtin trap 'builtin command -p rm -rf "$temporary_dir"' return
       builtin trap 'builtin exit 1' 1 2 3 15

       TMPDIR=${TMPDIR:-/tmp}
       temporary_file0=__${__sdb_name_}_tempfile0_$RANDOM
       temporary_dir=$(builtin command -p mktemp -d "$TMPDIR/XXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
       if ((__sdb_edit)); then
         builtin printf '%s\n' "${execute_var0%"|"*}" > "$temporary_dir/$temporary_file0"
         "${EDITOR:-vim}" "$temporary_dir/$temporary_file0" || builtin return
         while IFS= builtin read -u9 -r __sdb_evalcommands; do
           builtin history -s "$__sdb_evalcommands"
           { [[ -d "$__sdb_evalcommands" ]] && builtin shopt -q autocd ; } || printf '%s\n' "$__sdb_evalcommands"
           builtin eval "$__sdb_evalcommands" || builtin return
         done 9< "$temporary_dir/$temporary_file0"
         builtin return
       fi
     fi

# ******************************************************************************************** #
#      First sqlite3 command, just to print out a formatted output separated by a pipe.        #
# ******************************************************************************************** #

     if ((exit_stat)); then
       ExitStatus="substr('      '||max(exit_status),-6) ||
       ' | '||"
       stat0='--------+'
       stat1=' STATUS |'
       stat2='--------+'
     fi

     if ((user_host)); then
       User_Host="substr('             '||max(user_hosts),-20)||
       ' | '||"
       user0='----------------------+'
       user1='      USER@HOST       |'
       user2='----------------------+'
     fi

     if ((pwd)); then
       pwd_q="pwd || \"$separator\" ||"
     fi

     first_sql_commands="
       SELECT
       substr('           '||max(id),-12) ||
         ' | ' ||
         substr('      '||count(*),-6) ||
         ' | ' ||
         datetime(max(epoch), 'unixepoch', 'localtime') ||
         ' | ' ||
         $User_Host
         $ExitStatus
         $pwd_q
       cmd
       FROM history
       WHERE 1"

# ******************************************************************************************** #
#                  Assign the sqlite3 commands inside the sql_commands array.                  #
# ******************************************************************************************** #

     builtin declare -a sql_commands
     sql_commands+=("$first_sql_commands")

# ******************************************************************************************** #
#     Sqlite3 commands to be executed depending on the args/options given by the user.         #
# ******************************************************************************************** #

     if ((!all)); then
       sql_commands+=("AND (salt=\"$__sdb_salt\" AND ppid=\"$PPID\")")
     fi

     if ((!self)); then
       sql_commands+=("AND (cmd != 'sdb' AND cmd NOT LIKE 'sdb %')")
     fi

     if ((OnlyUser)); then
       sql_commands+=("AND (user_hosts LIKE \"$UserOnly\")")
     fi

     if ((OnlyHost)); then
       sql_commands+=("AND (user_hosts LIKE \"$HostOnly\")")
     fi

     if ((begin)); then
       query_begin=${query_begin//\"/\"\"}
       query_begin="$query_begin%"
       sql_commands+=("AND (cmd LIKE \"$query_begin\" ESCAPE '\')")
     fi

     if ((end)); then
       query_end=${query_end//\"/\"\"}
       query_end="%$query_end"
       sql_commands+=("AND (cmd LIKE \"$query_end\" ESCAPE '\')")
     fi

     if ((whole_line)); then
       query_whole=${query_whole//\"/\"\"}
       query_whole="%$query_whole%"
       sql_commands+=("AND (cmd LIKE \"$query_whole\" ESCAPE '\')")
     fi

     if ((path)); then
       if [[ -n $rpathquery ]]; then
         __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
         builtin return 1
       fi
       pathquery=${pathquery//\"/\"\"}
       sql_commands+=("AND (pwd = \"$pathquery\")")
     fi

     if ((rpath)); then
        if [[ -n $pathquery ]]; then
          __sdb_warn_ "conflicting options specified!" "Try '$__sdb_name_ --help'"
          builtin return 1
        fi
        rpathquery=${rpathquery//\"/\"\"}
       sql_commands+=("AND (pwd LIKE \"$rpathquery%\" ESCAPE '\')")
     fi

     if ((time_search)); then
       sql_commands+=("AND (epoch between $(builtin command -p date -d"${time_search0%,*}" "+%s") and $(builtin command -p date -d"${time_search0#*,}" "+%s"))")
     fi

     if ((numeric_status)); then
       if [[ $numeric_status_value = + ]]; then
         sql_commands+=("AND (exit_status > '0')")
       else
         sql_commands+=("AND (exit_status = $numeric_status_value)")
       fi
     fi

     sql_commands+=("GROUP BY cmd,exit_status,user_hosts")

     if ((pwd)); then
       sql_commands+=(,pwd)
       dir0='----------------+'
       dir1="   DIRECTORY    |${separator// }"
       dir2='----------------+'
       comm1='    COMMAND    |'
     fi

     sql_commands+=("ORDER BY max(id) DESC LIMIT $max;")

     __sdb__main_funct__() {
       if ((verbose)); then
         builtin printf '%s %s%s\n%s\n' "sqlite3" "$__sdb_file" "${sql_commands[*]}" "${blank_line+""}"
       fi

       builtin printf '%s\n%s\n%s\n' "$def0$user0$stat0$dir0$comm0" "$def1$user1$stat1$dir1$comm1" "$def2$user2$stat2$dir2$comm2"

      __sdb_sqlite < <(builtin printf '%s ' "${sql_commands[@]}") || builtin return
      builtin return
     }

     if ((!offpager)); then
       builtin trap 'builtin command -p rm -rf "$temporary_dir"' return
       builtin trap 'builtin exit 1' 1 2 3 15

       TMPDIR=${TMPDIR:-/tmp}
       temporary_file0=__${__sdb_name_}_tempfile0_$RANDOM
       temporary_dir=$(builtin command -p mktemp -d "$TMPDIR/XXXXXXXXXXXXXXXXXXXXXXXXXXXXX")
       __sdb__main_funct__ > "$temporary_dir/$temporary_file0" 2>&1 || builtin return
       if [[ $PAGER  = less ]]; then
         builtin command -p "$PAGER" -Ss "$temporary_dir/$temporary_file0" || builtin return
         builtin return
       fi
       "$PAGER" "$temporary_dir/$temporary_file0" || builtin return
       builtin return
     fi

     __sdb__main_funct__
     builtin return
  }

fi

# ******************************************************************************************** #
#          assign the function __sdb_prompt to the bash variable PROMPT_COMMAND.               #
# ******************************************************************************************** #

if [[ $PROMPT_COMMAND != *__sdb_prompt* ]]; then
  PROMPT_COMMAND="__sdb_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
fi

# ******************************************************************************************** #
#   A hack to send an error message when the script was invoke via the likes of 'bash ./sdb'   #
# ******************************************************************************************** #

(builtin return 2>/dev/null) || {
  __sdb_warn_ "To use '$__sdb_name_'" "Run: source $BASH_SOURCE"
  (builtin return 2>/dev/null)
}

# vim:ft=sh
# ============================================================================================ #
#                                   >>> END OF SCRIPT <<<                                      #
# ============================================================================================ #
