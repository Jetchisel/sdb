# ============================================================================================ #
#: Title           : sdb                                                                       #
#: Sypnosis        : sdb [OPTIONS]... [QUERY]...                                               #
#: Date Created    : Sat 25 Nov 2017 10:10:47 AM +08  /  Sat Nov 25 02:10:47 UTC 2017          #
#: Last Edit       : Mon 08 Jan 2018 10:03:37 AM +08  /  Mon Jan  8 02:03:37 UTC 2018          #
#: License         : MIT                                                                       #
#: Version         : 1.4.4                                                                     #
#: Maintainer      : Jason V. Ferrer '<jetchisel@opensuse.org>'                                #
#: Description     : log bash_history in a database (A fork of dbhist.sh from Dennis Gladkikh) #
#: Options         : [abdehlmnprsuvwzEHS]                                                      #
#: Home Page       : https://github.com/Jetchisel/sdb                                          #
#: ExtComm         : base64,dd,sqlite3,tput                                                    #
#: Copyright       : Jason V. Ferrer 2017 based on dbhist.                                     #
# ============================================================================================ #

################################################################################################
# The MIT License                                                                              #
# SPDX short identifier: MIT                                                                   #
#                                                                                              #
# Further resources on the MIT License                                                         #
# Copyright 2017 Denis Gladkikh (https://www.outcoldman.com/en/archive/2017/07/19/dbhist/)     #
# Permission is hereby granted, free of charge, to any person obtaining a copy                 #
# of this software and associated documentation files (the "Software"), to deal                #
# in the Software without restriction, including without limitation the rights                 #
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                    #
# copies of the Software, and to permit persons to whom the Software is                        #
# furnished to do so, subject to the following conditions:                                     #
#                                                                                              #
# The above copyright notice and this permission notice shall be included in                   #
# all copies or substantial portions of the Software.                                          #
#                                                                                              #
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                   #
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                     #
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                  #
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                       #
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                #
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE                #
# SOFTWARE.                                                                                    #
#                                                                                              #
# Copyright 2017 Jason V. Ferrer based on above.                                               #
#==============================================================================================#
# To use it, just source the file `source sdb`                                                 #
#                                                                                              #
# Configuration                                                                                #
#   SDB_HISTORY=true - use false to disable                                                    #
#   SDB_HISTORYFILE=$HOME/.bash_history.sqlite  - location of sdb sqlite3 database.            #
#                                                                                              #
# To make it work I keep next configuration for bash, the only important is the                #
# time format, to make it unixtime                                                             #
#                                                                                              #
#   HISTSIZE=$HOME/.bash_history                                                               #
#   HISTFILESIZE=1000                                                                          #
#   HISTSIZE=1000                                                                              #
#   HISTTIMEFORMAT="%s "                                                                       #
#   HISTCONTROL=ignorespace:erasedups                                                          #
################################################################################################

# ******************************************************************************************** #
#                       Enable extglob, just in case it is not enabled.                        #
# ******************************************************************************************** #

shopt -s extglob

# ******************************************************************************************** #
#                               Function to show the help menu.                                #
# ******************************************************************************************** #

____ShowHelp____() {

  local IFS help

IFS=$'\n' read -rd '' help <<<"
USAGE: ${BASH_SOURCE##*/} [OPTIONS]... [QUERY]...

Records bash_history to a database and query it.
Without any options/arguments the default is to show
the recent commands if there is/are any in the current
session.

OPTIONS:
  -a, --all               Include history of all sessions. Not only current.
  -b, --begin-with word   Match only commands that starts with word.
  -e, --end-with word     Match only commands that ends with word.
  -w, --with-word word    Match commands with word from beginning to end.
  -h, --help              Show this help.
  -d, --directory         Show the working directory of the commands.
  -l, --last-status       Show the exit status of the commands.
  -m, --max-count n       N numbers of latest commands to show. Defaults to 100.
  -n, --non-zero          Show commands that exited with non-zero status.
  -r, --recurse-path dir  Show commands executed inside and under the directory dir.
  -p, --path dir          Show commands executed inside the directory dir.
  -s, --self              Include history about ${BASH_SOURCE##*/}.
  -u, --under             Reduce search only for current and under pwd.
  -v, --verbose           Verbose output (shows sql command).
  -z, --zero              Show commands that exited with zero status.
  -E, --execute-id n      Execute the command with the n id.
  -H, --here              Reduce search only for current pwd.
  -S, --shell             Access to the sqlite3 shell and load the shell database.

Long options that takes an argument also supports the following syntax:

    --option=argument

Short options that does not take an argument ca be joined as one command:

    -adlsv

A newly open shell does not have any commands to show
unless the -a option is specified, which defaults to
100 lines, unless the -m option is specified.

The 1rst column shows only the increment of all the executed commands.
The 2nd column shows how many times the commands has been executed.
The 3rd column shows the date and time of the executed commands.
The 4rth column which is specified by the -l option shows the exit status.
The 5th column which is specified by the -d option shows the pwd.
The last column is/are the executed commands. separated by a > from the path column.

NOTE:
  Not all commands that exited with a non-zero is a failure, likewise not all commands
  that exited with zero is a success.
"
  printf '%s\n' "$help"
}

# ******************************************************************************************** #
#                                      The magic starts.                                       #
# ******************************************************************************************** #

if "${SDB_HISTORY:-true}"; then

  if ! type -P dd >/dev/null; then
      printf '%s: %s\n' "${BASH_SOURCE##*/}" "dd is either not installed or it is not in your PATH!" >&2
      return 1
   elif ! type -P base64 >/dev/null; then
      printf '%s: %s\n' "${BASH_SOURCE##*/}" "base64 is either not installed or it is not in your PATH!" >&2
      return 1
   else
      __sdb_salt=$(command dd if=/dev/urandom bs=32 count=1 2>/dev/null | command base64)
  fi

  __sdb_initialized=0

  __sdb_oldpwd=$OLDPWD

  __sdb_empty_data_base=0
  __sdb_does_not_exists=0

  __sdb_file=${SDB_DATABASE:-$HOME/.bash_history.sqlite}

  if type -P sqlite3 >/dev/null; then
    __sdb_sqlite() {
      command sqlite3 "$__sdb_file" "$@"
    }
  else
    printf '%s: %s\n' "${BASH_SOURCE##*/}" 'sqlite3 is either not installed or it is not in your PATH' >&2
    return 1
  fi

  __sdb_init() {
    local sql='CREATE TABLE history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    hist_id INTEGER,
    cmd TEXT,
    epoch INTEGER,
    ppid INTEGER,
    exit_status INTEGER,
    pwd TEXT,
    salt TEXT
    );'

    if [[ ! -f "$__sdb_file" ]]; then
      __sdb_sqlite <<< "$sql"
    fi
  }

  __sdb_prompt() {
    Last_Command=$?

    if ((!__sdb_initialized)); then
      __sdb_init
      __sdb_initialized=1
      return
    fi

    if ((!__sdb_does_not_exists)); then
      if [[ ! -f $__sdb_file ]]; then
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "It looks like $__sdb_file does not exists, please verify it." >&2
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "run: file $__sdb_file" >&2
        __sdb_does_not_exists=1
        return
      fi
    fi

    if ((!__sdb_empty_data_base)); then
      if [[ ! -s $__sdb_file  ]]; then
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "It looks like $__sdb_file is empty, please verify it." >&2
        printf '%s: %s\n' "${BASH_SOURCE##*/}" "run: file $__sdb_file" >&2
        __sdb_empty_data_base=1
        return
      fi
    fi

    if [[ -n $COMP_LINE ]]; then
      return
    fi

    local IFS
    local recent_command=""
    local num=""
    local epoch=""
    local pwd=$PWD
    local command=""
    local command__=""
    local regexp=""

    if [[ $OLDPWD !=  "$__sdb_oldpwd" ]]; then
      pwd=$OLDPWD
      __sdb_oldpwd=$OLDPWD
    fi

# ******************************************************************************************** #
# Set IFS to a newline, use reads -d option, so multiline command such a heredocs is captured. #
# ******************************************************************************************** #

    IFS=$'\n' read -u6 -rd '' recent_command 6< <(history 1)
    regexp='[[:space:]]+([[:digit:]]+)[[:space:]]+([[:digit:]]+)[[:space:]](.+)'

    if [[ $recent_command =~ $regexp ]]; then
      num=${BASH_REMATCH[1]}
      epoch=${BASH_REMATCH[2]}
      command=${BASH_REMATCH[3]}
    fi

# ******************************************************************************************** #
#             Insert data into the database using a while read loop and a heredoc.             #
# ******************************************************************************************** #

while read -r command__ <&8; do
    __sdb_sqlite <<-END
INSERT INTO history(hist_id, epoch, cmd, ppid, exit_status, pwd, salt)
VALUES(
   "$num",
   "$epoch",
   "${command__//\"/\"\"}",
   "$PPID",
   "$Last_Command",
   "${pwd//\"/\"\"}",
   "$__sdb_salt"
 );
END
done 8<<< "$command"

}

  sdb() {

# ******************************************************************************************** #
#                         Local variables from sdb prompt function.                            #
# ******************************************************************************************** #

     local max=100
     local all=0
     local begin=0
     local end=0
     local exit_stat=0
     local execute=0
     local self=0
     local whole_line=0
     local path=0
     local rpath=0
     local verbose=0
     local pwd=0
     local zero=0
     local nonzero=0
     local answer
     local dir0=""
     local dir1=""
     local dir2=""
     local execute_var=""
     local execute_var0=""
     local stat0=""
     local stat1=""
     local stat2=""
     local pwd_q=""
     local separator=""
     local ExitStatus=""
     local pathquery=""
     local rpathquery=""
     local query_begin=""
     local query_end=""
     local query_whole=""
     local location=""
     local optstring=""
     local first_sql_commands=""
     local G=""
     local R=""
     local comm0='----------------+'
     local comm1='   COMMAND      |'
     local comm2='----------------+'
     local def0='+-------+--------+---------------------+'
     local def1='|  ID   | COUNT  |      DATE/TIME      |'
     local def2='+-------+--------+---------------------+'

     if type -P tput >/dev/null; then
       G=$(command tput bold)
       R=$(command tput sgr0)
     fi

# ******************************************************************************************** #
# Getops from scratch by D.J. Mills, https://github.com/e36freak/templates/blob/master/options #
# ******************************************************************************************** #

     optstring=adsulnvzHSb:e:m:w:r:p:E:

     unset options

     while (($#)); do
       case $1 in

         -[!-]?*)

           for ((i=1; i<${#1}; i++)); do
             c=${1:i:1}

             options+=("-$c")

             if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
               options+=("${1:i+1}")
               break
             fi
           done
           ;;

         --?*=*) options+=("${1%%=*}" "${1#*=}");;

         --) options+=(--endopts);;

         *) options+=("$1");;
       esac
       shift
     done

     set -- "${options[@]}"

     if (( ${#options[@]} == 1 )); then
       if [[ ${options[0]} != -* ]]; then
         printf '%s: %s\n%s\n' "Unknown option" "$G${options[0]}$R" 'Try --help' >&2
         return 1
       fi
     fi

     unset options

# ******************************************************************************************** #
#                          Parse the command line arguments/options.                           #
# ******************************************************************************************** #

     while [[ $1 = -?* ]]; do
       case $1 in
         --shell|-S)
           __sdb_sqlite
           return
           ;;
         --help|-h)
           ____ShowHelp____
           return
           ;;
         --max-count|-m)
           shift
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" "Maxlimit requires a value!" >&2
             return 1
           elif [[ $1 != +([0-9]) ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Maxlimit should be a number!' >&2
             return 1
           fi
           max=$1
           ;;
         --all|-a)
           all=1
           ;;
         --last-status|-l)
           exit_stat=1
           ;;
         --self|-s)
           self=1
           ;;
         --begin-with|-b)
           shift
           begin=1
           if ((whole_line)); then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Conflicting options specified!' >&2
             return 1
           fi
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" "Begin requires a value!" >&2
             return 1
           fi
           query_begin=$1
           ;;
         --end-with|-e)
           shift
           end=1
           if ((whole_line)); then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Conflicting options specified!' >&2
             return 1
           fi
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'End requires a value!' >&2
             return 1
           fi
           query_end=$1
           ;;
         --recurse-path|-r)
           shift
           rpath=1
           pwd=1
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Path requires a value!' >&2
             return 1
           fi
           rpathquery=$1
           ;;
         --path|-p)
           shift
           path=1
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Path requires a value!' >&2
             return 1
           fi
           pwd=1
           pathquery=$1
           ;;
         --verbose|-v)
           verbose=1
           ;;
         --with-word|-w)
           shift
           whole_line=1
           if ((begin || end)); then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Conflicting options specified!' >&2
             return 1
           fi
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Word requires a value!' >&2
             return 1
           fi
           query_whole=$1
           ;;
         --execute-id|-E)
           shift
           execute=1
           if [[ -z $1 ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Id requires a value!' >&2
             return 1
           elif [[ $1 != +([0-9]) ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" "Id $G$1$R should be a number!" >&2
             return 1
           fi
           execute_var=$1
           ;;
         --here|-H)
           if [[ -n $location || -n $pathquery ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Specifier for pwd already set!' >&2
             return 1
           fi
           location=here
           ;;
         --under|-u)
           if [[ -n $location || -n $pathquery ]]; then
             printf '%s: %s\n' "${BASH_SOURCE##*/}" 'Specifier for pwd already set!' >&2
             return 1
           fi
           location=under
           ;;
         --directory|-d)
           pwd=1
           ;;
         --non-zero|-n)
           nonzero=1
           exit_stat=1
           ;;
         --zero|-z)
           zero=1
           exit_stat=1
           ;;
         --endopts)
           shift
           break
           ;;
         *)
           printf '%s: %s: %s\n' "${BASH_SOURCE##*/}" "Unknown option" "$G$1$R" >&2
           return 1
           ;;
       esac
       shift
     done

# ******************************************************************************************** #
#            The separator character to print, depending on the value of $DISPLAY.             #
# ******************************************************************************************** #

     if [[ -n $DISPLAY ]]; then
       separator=" ▶ "
     else
       separator=" > "
     fi

# ******************************************************************************************** #
# Run the command with the corresponding ID, with the all time favorite builtin command: EVAL  #
# ******************************************************************************************** #

     if ((execute)); then
       execute_var0=$(__sdb_sqlite "SELECT cmd from history WHERE 1 AND ( id = $execute_var );")
       if [[ -z $execute_var0 ]]; then
         printf '%s\n' "${BASH_SOURCE##*/}: Id $G$execute_var$R is either out of range or it has no corresponding command!" >&2
         return 1
       fi

       printf -v are_you_sure '%s\n%s' "Do you really want to run: $G$execute_var0$R" "[p/y/n]${separator// } "

       read -rp "$are_you_sure" answer
       case $answer in
         Y|y)
           history -s "$execute_var0"
           eval "$execute_var0"
           return $?
           ;;
         N|n) : ;;
         P|p) printf '\n%s\n' "$execute_var0"
           ;;
         *) printf '%s: %s\n' 'Unknown answer' "$G$answer$R" >&2
           return 1
           ;;
       esac
       return
     fi

# ******************************************************************************************** #
#      First sqlite3 command, just to print out a formatted output separated by a pipe.        #
# ******************************************************************************************** #

     if ((exit_stat)); then
       ExitStatus="substr('      '||max(exit_status),-4) ||
       ' | ' ||"
       stat0='------+'
       stat1='STATUS|'
       stat2='------+'
     fi

     if ((pwd)); then
       pwd_q="pwd || \"$separator\" ||"
     fi

     first_sql_commands="
       SELECT
       substr('      '||max(id),-7) ||
         ' | ' ||
         substr('      '||count(*),-6) ||
         ' | ' ||
         datetime(max(epoch), 'unixepoch', 'localtime') ||
         ' | ' ||
         $ExitStatus
         $pwd_q
       cmd
       FROM history
       WHERE 1"

# ******************************************************************************************** #
#                  Assign the sqlite3 commands inside the sql_commands array.                  #
# ******************************************************************************************** #

     declare -a sql_commands

     sql_commands+=("$first_sql_commands")

# ******************************************************************************************** #
#     Sqlite3 commands to be executed depending on the args/options given by the user.         #
# ******************************************************************************************** #

     if ((!all)); then
       sql_commands+=("AND (salt=\"$__sdb_salt\" AND ppid=$PPID)")
     fi

     if ((!self)); then
       sql_commands+=("AND (cmd != 'sdb' AND cmd NOT LIKE 'sdb %')")
     fi

     if ((begin)); then
       query_begin=${query_begin//\"/\"\"}
       query_begin="$query_begin%"
       sql_commands+=("AND cmd LIKE \"$query_begin\" ESCAPE '\' ")
     fi

     if ((end)); then
       query_end=${query_end//\"/\"\"}
       query_end="%$query_end"
       sql_commands+=("AND cmd LIKE \"$query_end\" ESCAPE '\' ")
     fi

     if ((whole_line)); then
       query_whole=${query_whole//\"/\"\"}
       query_whole="%$query_whole%"
       sql_commands+=("AND cmd LIKE \"$query_whole\" ESCAPE '\' ")
     fi

     pwd_l=${PWD//\"/\"\"}

     case $location in
       here)
         sql_commands+=("AND (pwd == \"$pwd_l\") ")
         ;;
       under)
         pwd_l=${pwd_l//%/\%}
         pwd_l=${pwd_l//_/\_}
         sql_commands+=("AND (pwd LIKE \"$pwd_l%\" ESCAPE '\') ")
         ;;
     esac

     if ((path)); then
       if [[ -n $rpathquery ]]; then
         printf '%s\n' 'Conflicting options' >&2
         return 1
       fi
       pathquery=${pathquery//\"/\"\"}
       sql_commands+=("AND pwd = \"$pathquery\" ")
     fi

     if ((rpath)); then
       if [[ -n $pathquery ]]; then
         printf '%s\n' 'Conflicting options' >&2
         return 1
       fi
       rpathquery=${rpathquery//\"/\"\"}
       sql_commands+=("AND (pwd LIKE \"$rpathquery%\" ESCAPE '\') ")
     fi

     if ((zero)); then
       if ((nonzero)); then
         printf '%s\n' 'Conflicting options!'
         return 1
       fi
       sql_commands+=("AND exit_status = '0' ")
     fi

     if ((nonzero)); then
       if ((zero)); then
         printf '%s\n' 'Conflicting options!'
         return 1
       fi
       sql_commands+=("AND exit_status > '0' ")
     fi

     sql_commands+=("GROUP BY cmd,exit_status")

     if ((pwd)); then
       sql_commands+=(,pwd)
       dir0='----------------+'
       dir1="   DIRECTORY    |${separator// }"
       dir2='----------------+'
       comm1='   COMMAND     |'
     fi

     sql_commands+=("ORDER BY max(id) DESC LIMIT $max;")

     if ((verbose)); then
       printf '%s\n' "${BASH_SOURCE##*/} $__sdb_file"  "${sql_commands[*]}" "${blank_line:-""}"
     fi

     printf  '\n%s\n%s\n%s\n' "$def0$stat0$dir0$comm0" "$def1$stat1$dir1$comm1" "$def2$stat2$dir2$comm2"

     __sdb_sqlite < <(printf '%s ' "${sql_commands[@]}")
  }

fi

# ******************************************************************************************** #
#          assign the function __sdb_prompt to the bash variable PROMPT_COMMAND.               #
# ******************************************************************************************** #

if [[ $PROMPT_COMMAND != *__sdb_prompt* ]]; then
  PROMPT_COMMAND="__sdb_prompt${PROMPT_COMMAND:+; $PROMPT_COMMAND}"
fi

# ============================================================================================ #
#                                   >>> END OF SCRIPT <<<                                      #
# ============================================================================================ #
